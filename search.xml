<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>复习2</title>
      <link href="/2019/09/21/%E5%A4%8D%E4%B9%A02/"/>
      <content type="html"><![CDATA[<p>复习整理二</p><a id="more"></a><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="一、基础班模块"><a href="#一、基础班模块" class="headerlink" title="一、基础班模块"></a>一、基础班模块</h2><h3 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>什么是HTML？</p><p>答：</p><blockquote><p>HTML并不是真正的的程序语言，他是一种标记语言，用来结构化和含义化你想要放在web网站上的那些内容。它由一系列的元素（elements）所组成，这些元素可以用来封装你的内容中担任不同工作的各部分和各个角色。</p></blockquote></li><li><p>什么是CSS？</p><p>答：</p><blockquote><p>就像 HTML，CSS 也不是真正的编程语言。它是样式表语言，也就是说，它允许你有 选择性的为 HTML 文档的元素添加样式。</p></blockquote></li><li><p>行内元素和块级元素的具体区别是什么？行内元素的padding和margin可设置吗？</p><p>答：</p><blockquote><p>块级元素(block)特性：</p><p>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;</p><p>宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;</p><p>内联元素(inline)特性：</p><p>和相邻的内联元素在同一行;</p><p>宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变（也就是padding和margin的left和right是可以设置的），就是里面文字或图片的大小。</p></blockquote></li><li><p>简述一下你对HTML语义化的理解？</p><p>答：</p><blockquote><ol><li>HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；</li><li>即使在没有样式CSS 的情况下也能以一种文档格式显示，并且是容易阅读的；</li><li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；</li><li>使阅读源代码的人更容易将网站分块，便于阅读、维护和理解；</li></ol></blockquote></li><li><p>rgba() 和 opacity 设置透明度的区别是什么？</p><p>答：</p><blockquote><p>rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）</p></blockquote></li><li><p>DOCTYPE的作用？</p><p>答：</p><blockquote><ol><li><!DOCTYPE> 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以</html></li></ol><p>何种模式来渲染文档。</p><ol start="2"><li>严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站</li></ol><p>点无法工作。</p><ol start="4"><li>DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现。</li></ol></blockquote></li><li><p>介绍一下你对浏览器内核的理解？都有哪些常见的浏览器内核？</p><p>答：</p><blockquote><p>要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释（如标准通用标记语言下的一个<br>应用 HTML、JavaScript）并渲染（显示）网页。 所以，通常所谓的浏览器内核也就是浏<br>览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。<br>不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里<br>的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显<br>示效果的原因。<br>常见浏览器内核：<br>Trident 内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称 MSHTML]<br>Gecko内核：Netscape6 及以上版本，FF,MozillaSuite/SeaMonkey 等。<br>Presto 内核：Opera7及以上。 [Opera内核原为：Presto，现为、Blink;]<br>Webkit 内核：Safari,Chrome 等。 [ Chrome 的：Blink（WebKit 的分支）]<br>EdgeHTML内核：Microsoft Edge。 [此内核其实是从 MSHTML fork 而来，删掉了几<br>乎所有的 IE私有特性</p></blockquote></li><li><p>CSS选择器权重如何计算？</p><p>答：</p><blockquote><p>页面显示样式的优先级取决于其“特殊性”’，特殊性越高，就显示最高的，当特殊性相<br>等<br>时，显示后者<br>特殊性表述为 4个部分：0,0,0,0<br>一个选择器的特殊性如下:</p><p>对于选择器是#id的属性值,特殊性值为：0,1,0,0<br>对于属性选择器，class或伪类，特殊性值为：0,0,1,0<br>对于标签选择器或伪元素，特殊性值为：0,0,0,1<br>通配符‘*’特殊性值为：0,0,0,0<br>内联样式特殊性值为：1,0,0,0</p></blockquote></li><li><p>对WEB标准以及W3C的理解与认识？</p><p>答：</p><blockquote><ol><li>标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外链 css 和 js 脚<br>本、结构行为表现的分离，</li><li>文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所<br>访问、更少的代码和组件，</li><li>容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提<br>高网站易用性。</li></ol></blockquote></li><li><p>CSS中优雅降级和渐进增强有什么区别？</p><p>答：</p><blockquote><p>优雅降级和渐进增强印象中是随着css3流出来的一个概念。由于低级浏览器不支持css3，但 css3 的效果又太优秀不忍放弃，所以在高级浏览中使用 css3 而低级浏览器只保证最基本的功能。咋一看两个概念差不多，都是在关注不同浏览器下的不同体验，关键的区别是他们所侧重的内容，以及这种不同造成的工作流程的差异。</p><p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。<br>“渐进增强”观点则认为应关注于内容本身。</p></blockquote></li><li><p>对BFC规范的理解有哪些？</p><p>答：</p></li></ol><blockquote><ol><li>定义：</li></ol><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，<br>只有 Block-level box 参与，它规定了内部的Block-level Box 如何布局，并且与这个区域<br>外部毫不相干。<br>布局规则：</p><p>A. 内部的Box 会在垂直方向，一个接一个地放置。</p><p>B. Box垂直方向的距离由 margin决定。属于同一个 BFC的两个相邻 Box的 margin 会发生重叠。</p><p>C. 每个元素的 margin box 的左边，与包含块border box 的左边相接触(对于从左往右的<br>格式化，否则相反)。即使存在浮动也是如此。</p><p>D. BFC 的区域不会与 float box 重叠。</p><p>E. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反<br>之也如此。</p><p>F. 计算 BFC 的高度时，浮动元素也参与计算。</p><ol start="2"><li><p>哪些元素会生成 BFC：</p><p>A. 根元素</p><p>B. float 属性不为 none</p><p>C. position为 absolute 或 fixed</p><p>D. display为inline-block， table-cell， table-caption， flex， inline-flex</p><p>F. overflow 不为 visible</p></li></ol></blockquote><ol start="12"><li><p>有多少种清除浮动的方法？</p><p>答：</p><blockquote><ol><li>父级div定义 height</li></ol><p>原理：父级 div手动定义 height，就解决了父级 div无法自动获取到高度的问题。 简单、<br>代码少、容易掌握 ，但只适合高度固定的布局.</p><ol start="2"><li>结尾处加空 div标签 clear：both</li></ol><p>原理：在浮动元素的后面添加一个空div兄弟元素，利用 css 提高的clear：both清除浮动，<br>让父级div能自动获取到高度 ，如果页面浮动布局多，就要增加很多空 div，让人感觉很<br>不好 .</p><ol start="3"><li>父级div定义 伪类：after 和 zoom</li></ol><p>/<em>清除浮动代码</em>/<br>.clearfix：after{<br>content：””；<br>display：block；<br>visibility：hidden；<br>height：0；<br>line-height：0；<br>clear：both；<br>}<br>.clearfix{zoom：1}<br>原理：IE8以上和非 IE浏览器才支持：after，原理和方法 2有点类似，zoom(IE专有属性)<br>可解决ie6，ie7 浮动问题 ，推荐使用，建议定义公共类，以减少CSS 代码。</p><ol start="4"><li>父级div定义 overflow：hidden</li></ol><p>超出盒子部分会被隐藏，不推荐使用.</p><ol start="5"><li>双伪元素法：<br>.clearfix：before，.clearfix：after {<br>content： “”；<br>display： block；<br>clear：both；<br>}<br>.clearfix {<br>zoom： 1；}</li></ol></blockquote></li></ol><h3 id="实际工作部分"><a href="#实际工作部分" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>HTML常见兼容性问题？</p><p>答：</p></li></ol><blockquote><ol><li>双边距BUG float引起的  使用display</li></ol><ol start="2"><li><p>3像素问题 使用float引起的 使用dislpay:inline -3px  </p></li><li><p>超链接hover 点击后失效  使用正确的书写顺序 link visited hover active</p></li><li><p>Iez-index问题 给父级添加position:relative</p></li><li><p>Png透明 使用js代码改</p></li><li><p>Min-height最小高度 ！Important解决’</p></li><li><p>select在ie6下遮盖使用iframe嵌套</p></li><li><p>为什么没有办法定义1px左右的宽度容器（IE6默认的行高造成的，使用over:hidden,zoom:0.08line-height:1px）</p></li><li><p>IE5-8不支持opacity，解决办法：</p><p>.opacity{</p><p>   opacity: 0.4</p><p>   filter: alpha(opacity=60); /* for IE5-7 */</p><p>   -ms-filter:”progid:DXImageTransform.Microsoft.Alpha(Opacity=60)”; /* for IE 8*/</p><p>}</p></li><li><p>IE6不支持PNG透明背景，解决办法: IE6下使用gif图片</p></li></ol></blockquote><ol start="2"><li><p>描述一个”reset”的CSS文件并如何使用它。知道<code>normalize.css</code>吗？你了解他们的不同之处？</p><p>答：</p><blockquote><pre><code>重置样式非常多，凡是一个前端开发人员肯定有一个常用的重置CSS文件并知道如何使用它们。他们是盲目的在做还是知道为什么这么做呢？原因是不同的浏览器对一些元素有不同的默认样式，如果你不处理，在不同的浏览器下会存在必要的风险，或者更有戏剧性的性发生。</code></pre><p>　　你可能会用Normalize来代替你的重置样式文件。它没有重置所有的样式风格，但仅提供了一套合理的默认样式值。既能让众多浏览器达到一致和合理，但又不扰乱其他的东西（如粗体的标题）。</p><p>　　在这一方面，无法做每一个复位重置。它也确实有些超过一个重置，它处理了你永远都不用考虑的怪癖，像HTML的audio元素不一致或line-height不一致。</p></blockquote></li><li><p>BFC是什么？</p><p>答：</p><blockquote><p>BFC（块级格式化上下文），一个创建了新的BFC的盒子是独立布局的，盒子内元素的布局不会影响盒子外面的元素。在同一个BFC中的两个相邻的盒子在垂直方向发生margin重叠的问题</p><p>BFC是指浏览器中创建了一个独立的渲染区域，该区域内所有元素的布局不会影响到区域外元素的布局，这个渲染区域只对块级元素起作用</p></blockquote></li><li><p>怎样实现三栏布局，两边宽度固定，中间自适应？</p><p>答：</p></li></ol><blockquote><p>圣杯布局  双飞翼布局</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;html&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;head&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;title&gt;&lt;/title&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         * &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             margin: 0;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             padding: 0;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         <span class="comment">#left &#123;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             width: 200px;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             height: 200px;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             <span class="built_in">float</span>: left;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             background-color: red;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         <span class="comment">#right &#123;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             width: 150px;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             height: 200px;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             <span class="built_in">float</span>: right;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             background-color: mistyrose;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         <span class="comment">#middle &#123;</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             height: 200px;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             margin: 0 150px 0 200px;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             background-color: saddlebrown;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">             word-break: <span class="built_in">break</span>-word;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">         &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;/style&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;/head&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;body&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;div id=<span class="string">"content"</span>&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;div id=<span class="string">"left"</span>&gt;我是左侧内容我是左侧内容我是左侧内容我是左侧内容我是左侧内容&lt;/div&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;div id=<span class="string">"right"</span>&gt;我是右侧内容我是右侧内容我是右侧内容我是右侧内容我是右侧内容我是右侧内容&lt;/div&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     &lt;div id=<span class="string">"middle"</span>&gt;我是中间内容我是中间内容我是中间内容我是中间内容我是中间内容我是中间内容我是中间内容我是中间内容我是中间内容我是中间内容&lt;/div&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;/div&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;/body&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &lt;/html&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote><ol start="5"><li><p>精灵图(CSS Sprites)的优点和缺点</p><p>答：</p><blockquote><p>  精灵图是一种网页图片应用处理方式。就是把网页中很多小背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background-repeat”，“background-position”的组合进行背景图显示及定位，达到显示某一部分背景图的效果。</p><p>  精灵图的优点：</p><ol><li><p>减少图片的体积，因为每个图片都有一个头部信息，把多个图片放到一个图片里，就会共用同一个头部信息，从而减少了字节数。</p></li><li><p>减少了网页的http请求次数，从而加快了网页加载速度，提高用户体验。</p></li><li><p>解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。</p></li><li><p>更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。</p><p>精灵图的缺点：</p></li><li><p>在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂；</p></li><li><p>在开发的时候比较麻烦，你要通过photoshop或其他工具测量计算每一个背景单元的精确位置，这是针线活，没什么难度，但是很繁琐；</p></li><li><p>在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的地方最好不要动，这样避免改动更多的css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动css。</p></li><li><p>精灵图不能随意改变大小和颜色。精灵图改变大小会失真模糊，降低用户体验，css3新属性可以改变精灵图颜色，但是比较麻烦，并且新属性有兼容问题。现在一般都是用web字体(图标字体)来代替精灵图。</p></li></ol></blockquote></li></ol><h2 id="二、JavaScript基础模块"><a href="#二、JavaScript基础模块" class="headerlink" title="二、JavaScript基础模块"></a>二、JavaScript基础模块</h2><h3 id="基础部分-1"><a href="#基础部分-1" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>JS中有哪些数据类型？</p><p>答：</p><blockquote><p>简单数据类型：Undefined、Null、Boolean、Number 和String。<br>复杂数据类型：Object</p></blockquote></li><li><p>“==”和”===” 的区别？</p><p>答：</p></li></ol><blockquote><p>前者会自动转换类型,而后者不会。</p><p>前者比较的是值，后者比较的是值和类型。</p></blockquote><ol start="3"><li><p>JS中的常用内置对象有哪些？并列举该对象的常用方法？</p><p>答：</p><blockquote><ol><li><p>Arguments 函数参数集合</p><p> arguments[ ] 函数参数的数组</p><p> Arguments 一个函数的参数和其他属性 </p><p>Arguments.callee 当前正在运行的函数 </p><p>Arguments.length 传递给函数的参数的个数 </p></li><li><p>Array 数组 </p><p>length属性 动态获取数组长度 </p><p>join() 将一个数组转成字符串。返回一个字符串。 </p><p>reverse() 将数组中各元素颠倒顺序 </p><p>delete运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。 </p><p>shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。</p><p> pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减1。 </p><p>unshift() 往数组前面添加一个或多个数组元素，长度要改变。</p><p>push() 往数组结尾添加一个或多个数组元素，长度要改变。</p><p>concat( ) 连接数组 </p><p>slice( ) 返回数组的一部分 </p><p>sort( ) 对数组元素进行排序 </p><p>splice( ) 插入、删除或替换数组的元素 </p><p>toLocaleString( ) 把数组转换成局部字符串 </p><p>toString( ) 将数组转换成一个字符串</p></li><li><p>Boolean 布尔对象 </p><p>Boolean.toString( ) 将布尔值转换成字符串 </p><p>Boolean.valueOf( ) Boolean对象的布尔值 </p></li><li><p>Error 异常对象 </p><p>Error.message 可以读取的错误消息 </p><p>Error.name 错误的类型 </p><p>Error.toString( ) 把Error 对象转换成字符串</p><p>EvalError 在不正确使用 eval()时抛出 </p><p>SyntaxError 抛出该错误用来通知语法错误 </p><p>RangeError 在数字超出合法范围时抛出 </p><p>ReferenceError 在读取不存在的变量时抛出 </p><p>TypeError 当一个值的类型错误时，抛出该异常 </p><p>URIError 由URl的编码和解码方法抛出 </p></li><li><p>Function 函数构造器 </p><p>Function 函数构造器 </p><p>Function.apply( ) 将函数作为一个对象的方法调用 </p><p>Function.arguments[] 传递给函数的参数 </p><p>Function.call( ) 将函数作为对象的方法调用 </p><p>Function.caller 调用当前函数的函数 </p><p>Function.length 已声明的参数的个数 </p><p>Function.prototype 对象类的原型 </p><p>Function.toString( ) 把函数转换成字符串</p></li><li><p>Math 数学对象</p><p>Math对象是一个静态对象 </p><p>Math.PI 圆周率。 </p><p>Math.abs() 绝对值。 </p><p>Math.ceil() 向上取整(整数加 1，小数去掉)。 </p><p>Math.floor() 向下取整(直接去掉小数)。 </p><p>Math.round() 四舍五入。 </p><p>Math.pow(x，y) 求 x的y次方。 </p><p>Math.sqrt() 求平方根。</p></li><li><p>Number 数值对象</p><p>Number.MAX_VALUE 最大数值 </p><p>Number.MIN_VALUE 最小数值 </p><p>Number.NaN 特殊的非数字值 </p><p>Number.NEGATIVE_INFINITY 负无穷大 </p><p>Number.POSITIVE_INFINITY 正无穷大 </p><p>Number.toExponential( ) 用指数计数法格式化数字</p><p>Number.toFixed( ) 采用定点计数法格式化数字 </p><p>Number.toLocaleString( ) 把数字转换成本地格式的字符串 </p><p>Number.toPrecision( ) 格式化数字的有效位</p><p>Number.toString( ) 将—个数字转换成字符串 </p><p>Number.valueOf( ) 返回原始数值 </p></li><li><p>Object 基础对象</p><p>Object 含有所有 JavaScript 对象的特性的超类 </p><p>Object.constructor 对象的构造函数 </p><p>Object.hasOwnProperty( ) 检查属性是否被继承 </p><p>Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型 </p><p>Object.propertyIsEnumerable( ) 是否可以通过 for/in循环看到属性 </p><p>Object.toLocaleString( ) 返回对象的本地字符串表示 </p><p>Object.toString( ) 定义一个对象的字符串表示 </p><p>Object.valueOf( ) 指定对象的原始值 </p></li><li><p>RegExp 正则表达式对象</p><p>RegExp.exec( ) 通用的匹配模式 </p><p>RegExp.global 正则表达式是否全局匹配 </p><p>RegExp.ignoreCase 正则表达式是否区分大小写 </p><p>RegExp.lastIndex 下次匹配的起始位置 </p><p>RegExp.source 正则表达式的文本 </p><p>RegExp.test( ) 检测一个字符串是否匹配某个模式 </p><p>RegExp.toString( ) 把正则表达式转换成字符串</p></li><li><p>String 字符串对象</p><p>Length 获取字符串的长度。</p><p>toLowerCase() 将字符串中的字母转成全小写。</p><p>toUpperCase() 将字符串中的字母转成全大写。</p><p>charAt(index) 返回指定下标位置的一个字符。如果没有找到，则返回空字符串。</p><p>substr() 在原始字符串，返回一个子字符串 </p><p>substring() 在原始字符串，返回一个子字符串。 </p><p>split() 将一个字符串转成数组。 </p><p>charCodeAt( ) 返回字符串中的第 n个字符的代码</p><p>concat( ) 连接字符串 </p><p>fromCharCode( ) 从字符编码创建—个字符串 </p><p>indexOf( ) 返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没 有找到，则返回-1。</p><p>lastIndexOf( ) 从后向前检索一个字符串 </p><p>localeCompare( ) 用本地特定的顺序来比较两个字符串 </p><p>match( ) 找到一个或多个正则表达式的匹配 </p><p>replace( ) 替换一个与正则表达式匹配的子串 </p><p>search( ) 检索与正则表达式相匹配的子串 </p><p>slice( ) 抽取一个子串 </p><p>toLocaleLowerCase( ) 把字符串转换小写 </p><p>toLocaleUpperCase( ) 将字符串转换成大写 </p><p>toLowerCase( ) 将字符串转换成小写 </p><p>toString( ) 返回字符串 </p><p>toUpperCase( ) 将字符串转换成大写 </p><p>valueOf( ) 返回字符串</p></li></ol></blockquote></li><li><p>什么是闭包？</p><p>答：</p><blockquote><p>简单的说，作用域是针对变量的，比如我们创建一个函数a1，函数里面又包了一 个子函数 a2。此时就存在三个作用域： 全局作用域、a1作用域、a2 作用域；即全局作用域包含了a1的作用域，a2 的作用 域包含了 a1的作用域。 当a1 在查找变量的时候会先从自身的作用域区查找，找不到再到上一级a2 的作用域 查找，如果还没找到就到全局作用域区查找，这样就形成了一个作用域链。 理解闭包首先要理解，js 垃圾回收机制，也就是当一个函数被执行完后，其作用域会被 收回，如果形成了闭包，执行完后其作用域就不会被收回。 如果某个函数被他的父函数之外的一个变量引用，就会形成闭包。 闭包的作用，就是保存自己私有的变量，通过提供的接口（方法）给外部使用，但外部 不能直接访问该变量。</p></blockquote></li><li><p>什么是原型链？</p><p>答：</p><blockquote><p>Javascript 是面向对象的，每个实例对象都有一个<strong>proto_属性，该属性指向它原 型对象，这个实例对象的构造函数有一个原型属性 prototype，与实例的</strong>proto__属性指 向同一个对象。当一个对象在查找一个属性的时，自身没有就会根据<strong>proto</strong> 向它的原型 进行查找，如果都没有，则向它的原型的原型继续查找，直到查到 Object.prototype._proto_为null，这样也就形成了原型链。</p></blockquote></li><li><p>有哪些方式继承？</p><p>答：</p></li></ol><blockquote><ol><li>借用构造函数。也叫伪造对象或经典继承。 思路：在子类构造函数的内部调用超类型构造函数。可以通过使用 apply()和call()方法 在新创建的对象上执行构造函数。 缺点：方法都在构造函数中定义，函数的复用就无从谈起。在超类型的原型中定义的方 法，对子类而言也是不可见的，结果所有的类型都只能使用构造函数模式。</li><li>组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起， 从而发挥二者之长。 思路：使用原型链实现对原型属性属性和方法的继承，通过借用构造函数来实现实例属 性的继承。 优点：既通过在原型上定义方法实现了函数复用，又能保证每一个实例都有它自己的数 组。 组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为 JavaScript 中常用的继承模式。</li><li>原型链继承。 思路：借助原型可以基于已有的对象创建对象，同时还不必因此创建自定义类型。 在object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为这个构造函 数的原型，最后返回了这个临时类型的一个新实例。</li><li>寄生式继承。 思路：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最 后再像真的是它做了所有的工作一样返回对象。缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用二降低效率，这一 点和构造函数模式类似。 </li><li>寄生组合式继承。是JavaScript 最常用的继承模式。 思路：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。 本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。 开发人员普遍认为寄生组合式继承时引用类型最理想的继承范式。 extend（）方法才用了这样的方式。</li></ol></blockquote><ol start="7"><li><p>字符创的常用方法有哪些？</p><p>答：</p></li></ol><blockquote><p>charCodeAt 方法返回一个整数，代表指定位置字符的 Unicode 编码；</p><p>charAt方法返回指定索引位置处的字符。如果超出有效范围的索引值返回空字符串； </p><p>slice方法返回字符串的片段；</p><p>substring方法返回位于String 对象中指定位置的子字符串。 </p><p>substr方法返回一个从指定位置开始的指定长度的子字符串。</p><p>indexOf方法返回 String 对象内第一次出现子字符串位置。如果没有找到子字符串， 则返回-1；</p><p>lastIndexOf方法返回 String对象中字符串最后出现的位置。如果没有匹配到子字符 串，则返回-1；</p><p>search方法返回与正则表达式查找内容匹配的第一个字符串的位置。 </p><p>concat 方法返回字符串值，该值包含了两个或多个提供的字符串的连接；</p><p>split 将一个字符串分割为子字符串，然后将结果作为字符串数组返回；</p></blockquote><ol start="8"><li><p>DOM节点的增删改查？</p><p>答：</p></li></ol><blockquote><ol><li><p>创建节点、追加节点</p><p>createElement（标签名）创建一个元素节点（具体的一个元素）。</p><p>createTextNode（节点文本内容）创建一个文本节点。</p><p>createDocumentFragment() //创建一个 DOM 片段。</p><p>appendChild（节点）追加一个节点。</p></li><li><p>插入节点</p><p>appendChild（节点）也是一种插入节点的方式，还可以添加已经存在的元素，会将其<br>元素从原来的位置移到新的位置。</p><p>insertBefore（a,b）是参照节点，意思是 a节点会插入 b节点的前面。</p></li><li><p>删除、移除节点</p><p>removeChild(节点) 删除一个节点，用于移除删除一个参数（节点）。其返回的被移除<br>的节点，被移除的节点仍在文档中，只是文档中已没有其位置了。</p></li><li><p>复制节点</p><p>cloneNode() 方法，用于复制节点， 接受一个布尔值参数， true 表示深复制（复制节点<br>及其所有子节点）， false 表示浅复制（复制节点本身，不复制子节点）。</p></li><li><p>替换节点</p><p>replaceChild(插入的节点，被替换的节点) ，用于替换节点，接受两个参数，第一参数<br>是要插入的节点，第二个是要被替换的节点。返回的是被替换的节点。</p></li><li><p>查找节点</p><p>getElementsByTagName() //通过标签名称<br>getElementsByName() //通过元素的Name 属性的值(IE容错能力较强，会得到一<br>个数组，其中包括 id等于 name值的)<br>getElementById() //通过元素 Id，唯一性</p></li></ol></blockquote><ol start="9"><li><p>什么是预解析？</p><p>答：</p></li></ol><blockquote><p>在代码整体执行之前，先解析一部分。 </p><p>预解析之后，代码才会从上往下依次整体执行，但是预解析执行过的代码不会 重复执行。</p><p>js预解析干了什么事：js 中预解析会把声明部分的代码预先执行。 </p><p>声明相关的代码可以分为两部分： </p><p>1、 变量声明 通过 var关键字定义的变量。</p><p>2、函数声明 通过 function关键字声明的函数</p><p>预解析时如果遇到重复的变量声明，那么忽略。 </p><p>预解析时如果遇到重复的函数声明，保留后面的函数。 </p><p>预解析时如果遇到变量与函数重名的情况，保留函数。</p></blockquote><ol start="10"><li><p>什么是变量名提升？</p><p>答：</p></li></ol><blockquote><p>使用 var关键字定义的变量，被称为变量声明； </p><p>函数声明提升的特点是，在函数声明的前面，可以调用这个函数。</p></blockquote><ol start="11"><li><p>JS中的typeof关键字能返回哪些数据类型？</p><p>答：</p><blockquote><p>typeof一般判断基本数据类型。是一个操作符而不是函数，圆括号可有可无。 </p><p>typeof 返回值有：string，number，boolean，undefined，object ，function， </p><p>基本数据类型：Boolean、Number、String、Undefined、Null </p><p>基本数据类型中数字，字符串，布尔类型返回其对类型 undefined返回 undefined </p><p>九大内置构造函数及其他所有函数返回function； </p><p>其他所有复杂类型对象和null返回 object </p></blockquote></li><li><p>简述创建函数的几种方式？</p><p>答：</p><blockquote><ol><li><p>函数声明</p><p> function sum1(num1,num2){</p><p> return num1+num2;</p><p>}</p></li><li><p>函数表达式</p><p>var sum2 = function(num1,num2){</p><pre><code>return num1+num2;</code></pre><p>}</p></li><li><p>函数对象方式</p><p>var sum3 = new Function(“num1”,”num2”,”return num1+num2”);</p></li></ol></blockquote></li><li><p>代码实现数组排序并去重</p><p>答：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span><span class="params">(arr)</span>&#123;</span></span><br><span class="line">  <span class="keyword">for</span>(var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; arr.<span class="built_in">length</span><span class="number">-1</span>; <span class="built_in">i</span>++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(var <span class="built_in">j</span> = <span class="number">0</span>; <span class="built_in">j</span> &lt; arr.<span class="built_in">length</span><span class="number">-1</span>-<span class="built_in">i</span>; <span class="built_in">j</span>++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[<span class="built_in">j</span>]&lt;arr[<span class="built_in">j</span>+<span class="number">1</span>])&#123;</span><br><span class="line">        var temp = arr[<span class="built_in">j</span>];</span><br><span class="line">        arr[<span class="built_in">j</span>] = arr[<span class="built_in">j</span>+<span class="number">1</span>];</span><br><span class="line">        arr[<span class="built_in">j</span>+<span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(var k = <span class="number">0</span>; k &lt; arr.<span class="built_in">length</span>; k++)&#123;</span><br><span class="line">    var c = arr[k];</span><br><span class="line">    <span class="keyword">for</span>(var l = k+<span class="number">1</span>; l &lt; arr.<span class="built_in">length</span>; l++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[l] == c)&#123;</span><br><span class="line">        arr.splice(l, <span class="number">1</span>);</span><br><span class="line">        l--;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">console.<span class="built_in">log</span>(fn(arr))</span><br></pre></td></tr></table></figure><p>14.写出下面代码输出的结果</p><p>A. console.log( undefined || 1 );      –&gt;  1</p><p>B. console.log( null || NaN );            –&gt;   NaN</p><p>C. console.log( 0 &amp;&amp; 1 );                     –&gt;   0</p><p>D. console.log( 0 &amp;&amp; 1 || 0 );            –&gt;   0</p><ol start="15"><li><p>下列代码将会输出什么？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( foo );   --&gt;  <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log( foo );   --&gt;  <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="实际工作部分-1"><a href="#实际工作部分-1" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>什么是短路表达式？</p><p>答：</p><blockquote><p>短路表达式只是一种简写形式，也就是用 &amp;&amp; 和 || 来赋值或者执行函数的形式</p><p>例如：</p><p>var foo = foo1 || foo2;</p><p>意思是如果foo1是真的，那么就把foo1的值赋给foo，否则把foo2的值赋给foo。</p><p>foo &amp;&amp; foo()</p><p>当foo存在的时候，我们就执行foo函数，如果这个时候foo不是一个函数，就会报错，所以这个只是一种简写形式而已。</p></blockquote></li><li><p>控制台中使用哪些部分调试？</p><p>答：</p><blockquote><p>主要用console来进行调试</p><ol><li>console.log 用于输出普通信息</li><li>console.info 用于输出提示性信息</li><li>console.error用于输出错误信息</li><li>console.warn用于输出警示信息</li><li>console.debug用于输出调试信息</li></ol></blockquote></li></ol><h2 id="三、Web-API模块"><a href="#三、Web-API模块" class="headerlink" title="三、Web API模块"></a>三、Web API模块</h2><h3 id="基础部分-2"><a href="#基础部分-2" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>要你出一套适应不同分辨率，不同终端的前端实现方案你有什么思路？</p><p>答：</p><blockquote><ol><li>流式布局：</li></ol><p>使用非固定像素来定义网页内容，也就是百分比布局，通过盒子的宽度设置成百分比来<br>根据屏幕的宽度来进行伸缩，不受固定像素的限制，内容向两侧填充。这样的布局方式，就<br>是移动web 开发使用的常用布局方式。这样的布局可以适配移动端不同的分辨率设备。</p><ol start="2"><li>响应式开发：</li></ol><p>那么 EthanMarcotte 在2010 年 5月份提出的一个概念，简而言之，就是一个网站能<br>够兼容多个终端。越来越多的设计师也采用了这种设计。<br>CSS3中的 Media Query（媒介查询），通过查询 screen 的宽度来指定某个宽<br>度区间的网页布局。<br>超小屏幕（移动设备） 768px以下<br>小屏设备 768px-992px<br>中等屏幕 992px-1200px<br>宽屏设备 1200px 以上<br>由于响应式开发显得繁琐些，一般使用第三方响应式框架来完成，比如bootstrap 来<br>完成一部分工作，当然也可以自己写响应式。</p></blockquote></li><li><p>px em rem 取用选择依据？</p><p>答：</p><blockquote><ol><li>px 像素（Pixel）。绝对单位。像素px是相对于显示器屏幕分辨率而言的，是一</li></ol><p>个虚拟长度单位，是计算机系统的数字化图像长度单位，如果 px要换算成物理长度，需要<br>指定精度 DPI。</p><ol start="2"><li>em是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字</li></ol><p>体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因<br>此并不是一个固定的值。</p><ol start="3"><li>rem是 CSS3新增的一个相对单位（root em，根em），使用 rem 为元素设定字</li></ol><p>体大小时，仍然是相对大小，但相对的只是HTML根元素。</p><ol start="4"><li>区别：IE无法调整那些使用 px作为单位的字体大小，而em 和rem可以缩放，rem</li></ol><p>相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既<br>可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁<br>反应。目前，除了 IE8及更早版本外，所有浏览器均已支持rem。</p></blockquote></li><li><p>Zepto和jQuery的区别？</p><p>答：</p><blockquote><p>Zepto相对jQuery更加轻量，主要用在移动端，jQuery也有对应的jQuerymobile移动端框架。</p></blockquote></li></ol><h3 id="实际工作部分-2"><a href="#实际工作部分-2" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>移动端touch事件判断滑屏手势的方向？</p><p>答：</p><blockquote><p>当开始一个touchstart事件的时候，获取此刻手指的横坐标startX和纵坐标startY；<br>当触发touchmove事件时，在获取此时手指的横坐标moveEndX和纵坐标moveEndY;最后，通过这两次获取的坐标差值来判断手指在手机屏幕上的滑动方向。<br>思路：用touchmove的最后坐标减去touchstart的起始坐标，X的结果如果正数，则说明手指是从左往右划动；X的结果如果负数，则说明手指是从右往左划动；Y的结果如果正数，则说明手指是从上往下划动；Y的结果如果负数，则说明手指是从下往上划动。</p><p>具体代码如下：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var mybody = document.getElementsByTagName(<span class="string">'body'</span>)[0];</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> //滑动处理</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> var startX, startY, moveEndX, moveEndY, X, Y;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mybody.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">function</span>(e) &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     e.preventDefault();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     startX = e.touches[0].pageX;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     startY = e.touches[0].pageY;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> mybody.addEventListener(<span class="string">'touchmove'</span>, <span class="keyword">function</span>(e) &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     e.preventDefault();</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     moveEndX = e.changedTouches[0].pageX;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     moveEndY = e.changedTouches[0].pageY;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     X = moveEndX - startX;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     Y = moveEndY - startY;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="keyword">if</span> ( X &gt; 0 ) &#123;alert(‘向右’);&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="keyword">else</span> <span class="keyword">if</span> ( X &lt; 0 ) &#123;alert(‘向左’);&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="keyword">else</span> <span class="keyword">if</span> ( Y &gt; 0) &#123;alert(‘向下’);&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="keyword">else</span> <span class="keyword">if</span> ( Y &lt; 0 ) &#123; alert(‘向上’);&#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">     <span class="keyword">else</span>&#123;alert(‘没滑动’); &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>移动端对图片优化有哪些方式，怎么实现？</p><p>答：</p><blockquote><p>懒加载，使用CSS Sprites合并为一张大图，首先从图片格式方面着手，webp(google官方网址)是谷歌推出的一种图片格式，优点在于同等画面质量下，体积比jpg、png少了25%以上，去掉无意义的修饰，使用矢量图替代位图。<br>按照HTTP协议设置合理的缓存。<br>详见链接 <a href="http://web.jobbole.com/81766/" target="_blank" rel="noopener">http://web.jobbole.com/81766/</a></p></blockquote></li><li><p>rem布局中的尺寸是怎样计算的，实际举例说明一下？</p><p>答：</p><blockquote><p>其实rem布局的本质是等比缩放，一般是基于宽度，试想一下如果UE图能够等比缩放，假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示，x = 屏幕宽度 / 100，如果将x作为单位，x前面的数值就代表屏幕宽度的百分比。</p></blockquote></li></ol><h2 id="四、JavaScript高级模块"><a href="#四、JavaScript高级模块" class="headerlink" title="四、JavaScript高级模块"></a>四、JavaScript高级模块</h2><h3 id="基础部分-3"><a href="#基础部分-3" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>说说你对this关键字的理解？</p><p>答：</p><blockquote><p>this 是一个关键字，它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用。 </p><p>1.作为纯粹的函数调用 this 指向全局对象 </p><p>2.作为对象的方法调用 this 指向调用对象 </p><p>3.作为构造函数被调用 this 指向新的对象（new会改变 this 的指向） </p><p>4.apply 调用 this 指向 apply方法的第一个参数</p></blockquote></li><li><p>表单验证传输的什么数据？明文还是暗文==加密？如何加密？是每一次传<br>输数据，都是加密之后才传输吗？</p><p>答：</p><blockquote><ol><li><p>概述： GET是从服务器上请求数据，POST 是发送数据到服务器。事实上，GET方法是把数 据参数队列（query string）加到一个URL上，值和表单是一一对应的。比如说， name=John。在队列里，值和表单用一个&amp;符号分开，空格用+号替换，特殊的符号转换 成十六进制的代码。因为这一队列在 URL里边，这样队列的参数就能看得到，可以被记录 下来，或更改。通常GET 方法还限制字符的大小（大概是 256 字节 ）。事实上POST 方法可以没有时间限制的传递数据到服务器，用户在浏览器端是看不到 这一过程的，所以 POST方法比较适合用于发送一个保密的（比如信用 卡号）或者比较大 量的数据到服务器。 </p></li><li><p>区别： Post 是允许传输大量数据的方法，而 Get 方法会将所要传输的数据附在网址后面，然 后一起送达服务器，因此传送的数据量就会受到限制，但是执行效率却比 Post 方法好。 </p></li><li><p>总结： </p><p>1、get 方式的安全性较Post 方式要差些，包含机密信息的话，建议用 Post 数据提交 方式； </p><p>2、在做数据查询时，建议用 Get 方式；而在做数据添加、修改或删除时，建议用Post 方式； </p></li><li><p>所以： 表达如果是向服务器传输数据(如帐号密码等)都是加密数据(post)，如果只是单单想要 从服务器获得数据或者传输的数据并不重要， 可以直接使用明文方式传输( get )</p></li></ol></blockquote></li><li><p>如何实现跨域？</p><p>答：</p><blockquote><p>JSONP(JSON with Padding 填充式JSON 或参数式 JSON) </p><p>在js 中，我们虽然不能直接用XMLHttpRequest 请求不同域上的数据，但是在页面上引入不同域上的js 脚本文件却是可以的，jsonp正是利用这个特性来实现的。</p><p>JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON 数据。</p><p>优点： 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest 或 ActiveX 的支持； 能够直接访问响应文本，支持在浏览器与服务器之间双向通信 </p><p>缺点： JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些 恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己 运维的Web 服务时，一定得保证它安全可靠。 它只支持 GET请求而不支持 POST等其它类型的 HTTP 请求；它只支持跨域 HTTP 请 求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript调用的问题</p></blockquote></li><li><p>说说事件委托机制？这样做有什么好处？</p><p>答：</p><blockquote><p>事件委托，就是某个事件本来该自己干的，但是自己不干，交给别人来干。就叫事件委 托。打个比方：一个button 对象，本来自己需要监控自身的点击事件，但是自己不来监控这个点击事件，让自己的父节点来监控自己的点击事件。</p><p>优点：</p><p> 提高性能：列如，当有很多 li同时需要注册事件的时候，如果使用传统方法来注册 事件的话，需要给每一个 li 注册事件。然而如果使用委托事件的话，就只需要将事件委托给 该一个元素即可。这样就能提高性能。 </p><pre><code>新添加的元素还会有之前的事件；</code></pre></blockquote></li><li><p>call和apply的区别？</p><p>答：</p><blockquote><p>它们的共同之处：都“可以用来代替另一个对象调用一个方法，将一个函数的对象上 下文从初始的上下文改变为由 thisObj 指定的新对象。” </p><p>它们的不同之处： </p><pre><code>Apply：最多只能有两个参数——新this 对象和一个数组 argArray。如果给该方法传递多 个参数，则把参数都写进这个数组里面，当然，即使只有一个参数，也要写进数组里面。如 果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被 用作 thisObj， 并且无法被传递任何参数Call：则是直接的参数列表，主要用在js 对象各方法互相调用的时候，使当前 this 实例指 针保持一致，或在特殊情况下需要改变this指针。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 </code></pre></blockquote></li><li><p>在JS的计时器运行原理是怎样的，为什么可以触发计时效果? 计时器是多线程吗?</p><p>答：</p><blockquote><ol><li>javascript引擎只有一个线程，强迫异步事件排队等待被执行。 </li><li>setTimeout 和setInterval 本质上不同的地方是他们如何执行异步代码的。 </li><li>如果一个定时器正在执行的时候被阻塞了，那么它将会被推迟到下一个可能的执行点，这既是使得延迟时间有可能会超过声明定时器时设置的值。 </li><li>Interval 如果有足够的时间来执行（大于制定的延迟），那么它将会无延迟的一个紧 接着一个执行。 </li><li>原理： 计时器通过设定一定的时间段（毫秒）来异步的执行一段代码。因为 Javascript 是一 个单线程语言，计时器提供了一种绕过这种语言限制来执行代码的能力。 </li><li>总结： 计时器是单线程的， 需要等待上一个执行完， 如果上一个没有执行完， 下一个需要 延迟执行， 直到上一个执行完。</li></ol></blockquote></li><li><p>什么是事件的冒泡和捕获？</p><p>答：</p><blockquote><p>事件冒泡：子元素事件的触发会影响父元素事件； </p><p>开关事件冒泡： </p><pre><code>A，开启事件冒泡：element.addEventListener(eventName，handler，false)； B，关闭事件冒泡：假设传统方式事件的返回值为 e，就可以通过 e.stopPropagation()来关闭事件冒泡； </code></pre><p>事件捕获：父元素的事件会影响子元素的事件； </p><p>开启事件捕获：element.addEventListener(eventName，handler，true)</p></blockquote></li><li><p>面向对象和类的区别？</p><p>答：</p><blockquote><p>简单的说类是对象的模版。</p><pre><code>在 js 中没有类， 所以在js 中所谓的 类 就是构造函数， 对象就是由构造函数创建出来的实例对象。面向对象就是使用面向对象的方式处理问题， 面向对象是对面向过程进行封装。</code></pre><p>面向对象有三大特性</p><pre><code>抽象性， 需要通过核心数据和特定环境才能描述对象的具体意义封装性， 封装就是将数据和功能组合到一起， 在js 中对象就是键值对的集合， 对象将属性和方法封装起来， 方法将过程封装起来继承性，将别人的属性和方法成为自己的，传统继承基于模板(类)，js 中继承基于 构造函数</code></pre></blockquote></li></ol><h3 id="实际工作部分-3"><a href="#实际工作部分-3" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>JavaScript 中的垃圾回收机制?</p><p>答：</p><blockquote><p>在Javascript 中，如果一个对象不再被引用，那么这个对象就会被GC 回收。如 果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。 因为函数 a被b引用，b又被 a外的 c引用，这就是为什么 函数 a 执行后不会被回收的原 因。</p></blockquote></li><li><p>列出3条以上 FF 和 IE 的脚本兼容问题</p><p>答：</p><blockquote><ol><li><p>window.event： </p><p>表示当前的事件对象，IE有这个对象，FF没有，FF通过给事件处理函数传递事件对象 </p></li><li><p>获取事件源 </p><p>IE用srcElement获取事件源，而FF用target获取事件源 </p></li><li><p>添加，去除事件 </p><p>IE：element.attachEvent(“onclick”,function)        element.detachEvent(“onclick”, function) </p><p>FF：element.addEventListener(“click”,function, true) element.removeEventListener(“click”, function, true) </p></li><li><p>获取标签的自定义属性 </p><p>IE：div1.value或div1[“value”] </p><p>FF：可用div1.getAttribute(“value”)</p></li></ol></blockquote></li><li><p>用正则表达式，写出由字母开头，其余由数字、字母、下划线组成的6~30的字符串？</p><p>答：</p><blockquote><p>/^[a-zA-Z]{1}[\w]{5,29}$/</p></blockquote></li><li><p>下列JavaScript代码执行后，iNum的值是多少？</p><blockquote><p>var iNum = 0;</p><p>for(var i = 1; i &lt; 10; i++){</p><pre><code>if(i% 5 == 0){</code></pre><p>  continue;</p><p>  }</p><pre><code>iNum++;</code></pre><p>}</p></blockquote><blockquote><p>答：8</p></blockquote></li><li><p>程序中捕获异常的方法？</p><p>答：</p><blockquote><p>window.error</p><p>try{}catch(error){}finally{}</p></blockquote></li><li><p>正则匹配邮箱？</p><p>答：</p><blockquote><p>/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;</p></blockquote></li><li><p>Javascript中callee和caller的作用？</p><p>答：</p><blockquote><p>caller是返回一个对函数的引用，该函数调用了当前函数；</p><p>callee是返回正在被执行的function函数，也就是所指定的function对象的正文。</p></blockquote></li><li><p>下列代码的输出结果？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log( tmp );</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.x );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> f1();</span><br><span class="line"><span class="built_in">console</span>.log( obj.x );</span><br><span class="line"><span class="built_in">console</span>.log( f1() );</span><br></pre></td></tr></table></figure><p>答：</p><blockquote><p>首先看代码（1），这里实例话化了f1这个类。相当于执行了 f1函数。所以<strong>这个时候 A 会输出 1</strong>， 而 B 这个时候的 this 代表的是实例化的当前对象 obj ,<strong>B 输出 3</strong>。 </p><p>代码（2）毋庸置疑<strong>会输出 3</strong>， </p><p><strong>重点</strong> 代码（3）首先这里将<strong>不再是一个类</strong>，它<strong>只是一个函数</strong>。那么 <strong>A输出 1</strong>， B呢？这里的this 代表的其实就是window对象，那么this.x 就是一个全局变量 相当于在外部 的一个全局变量。所以<strong>B 输出 3</strong>。最后代码由于<strong>f没有返回值</strong>那么一个函数如果没返回值的话，将会*<em>返回 underfined *</em>，所以答案就是 ： 1， 3， 3， 1， 3， underfined 。</p></blockquote></li><li><p>下面代码输出结果？</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeObjectProperty</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.csser.com/"</span>;</span><br><span class="line">  o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.siteUrl = <span class="string">"http://www.popcg.com/"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> CSSer = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">changeObjectProperty( CSSer );</span><br><span class="line"><span class="built_in">console</span>.log( CSSer.siteUrl );</span><br></pre></td></tr></table></figure><p>答：</p><blockquote><p><code>&quot;http://www.popcg.com/&quot;</code></p></blockquote></li></ol><h2 id="五、jQuery模块"><a href="#五、jQuery模块" class="headerlink" title="五、jQuery模块"></a>五、jQuery模块</h2><h3 id="基础部分-4"><a href="#基础部分-4" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>谈谈你对jQuery的理解？</p><p>答：</p><blockquote><p>JQuery 是继 prototype 之后又一个优秀的 Javascript 库。它是轻量级的js 库 ，它<br>兼容 CSS3，还兼容各种浏览器（IE 6.0+，FF1.5+，Safari 2.0+，Opera 9.0+），jQuery2.0<br>及后续版本将不再支持 IE6/7/8 浏览器。jQuery 使用户能更方便地处理 HTML（标准通用<br>标记语言下的一个应用）、events、实现动画效果，并且方便地为网站提供 AJAX 交互。<br>jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，<br>同时还有许多成熟的插件可供选择。jQuery 能够使用户的 html页面保持代码和 html 内容<br>分离，也就是说，不用再在 html里面插入一堆 js 来调用命令了，只需要定义 id即可。<br>jQuery 是一个兼容多浏览器的 javascript 库，核心理念是write less，do more(写<br>得更少，做得更多)。 jQuery是免费、开源的，使用 MIT 许可协议。jQuery 的语法设<br>计可以使开发更加便捷，例如操作文档对象、选择 DOM 元素、制作动画效果、事件处理、<br>使用 Ajax 以及其他功能。除此以外，jQuery 提供 API让开发者编写插件。其模块化的使<br>用方式使开发者可以很轻松的开发出功能强大的静态或动态网页。</p></blockquote></li><li><p>、原生JS的window.onload与Jquery的$(document).ready(function<br>() {})，$(function () {})有什么不同？</p><p>答：</p><blockquote><p>1.执行时间 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是 DOM 结构绘制完毕后就执行，不必等到加载完毕。</p><p> 2.编写个数不同 window.onload不能同时编写多个，如果有多个 window.onload 方法，只会执 行一个 $(document).ready()可以同时编写多个，并且都可以得到执行 </p><p>3.简化写法 window.onload没有简化写法 </p><pre><code>$(document).ready(function (){}) 可以简写成$(function(){})；</code></pre></blockquote></li><li><p>jQuery一个对象可以同时绑定多个事件，是如何实现的？</p><p>答：</p><blockquote><p>jQuery可以给一个对象同时绑定多个事件，低层实现方式是使用addEventListner或attachEvent兼容不同的浏览器实现事件的绑定，这样可以给同一个对象注册多个事件。</p></blockquote></li><li><p>jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？</p><p>答：</p><blockquote><p>this执行init构造函数自身，其实就是jQuery实例对象，返回this是为了实现jQuery的链式操作</p></blockquote></li><li><p>jQuery.extend和jQuery.fn.extend有什么区别？</p><p>答：</p><blockquote><p>Jquery.extend用来扩展jQuery对象本身；jquery.fn.extend用来扩展jQuery实例</p></blockquote></li></ol><h3 id="实际工作部分-4"><a href="#实际工作部分-4" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>jQuery框架中$.ajax()的常用参数有哪些？写一个post请求并带有发送数据和返回数据的样例？</p><p>答：</p><blockquote><p>async是否异步</p><p>url请求地址</p><p>contentType发送信息至服务器时内容编码类型</p><p>data发送到服务器的数据</p><p>dataType预期服务器返回的数据类型</p><p>type请求类型</p><p>success请求成功回调函数</p><p>error请求失败回调函数</p><p>$.ajax({</p><p> url: “/jquery/test1.txt”,</p><p>  type: ‘post’,</p><p>  data: { id: 1 },</p><p> success: function ( data ) { alert(data); }</p><p>  })</p></blockquote></li><li><p>举一下jquery中的函数，这些函数实现链式编程的原理？</p><p>答：</p><blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> toggle（fn, fn）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $（“td”）.toggle（</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">function</span>（）&#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $（this）.addClass（“selected”）;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> &#125;，</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="keyword">function</span>（）&#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> $（this）.removeClass（“selected”）;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ）</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 实现函数链式编程的原理：返回自身，其他过程在函数内部实现，其好处是：节约js代码，返回的是同一个对象，提高代码的效率。</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></blockquote></li></ol><h2 id="六、PHP后台开发模块"><a href="#六、PHP后台开发模块" class="headerlink" title="六、PHP后台开发模块"></a>六、PHP后台开发模块</h2><h3 id="基础部分-5"><a href="#基础部分-5" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>php inset 和 empty 的区别？</p><p>答：</p></li></ol><blockquote><p>1、empty函数 </p><p>用途：检测变量是否为空</p><p>判断：如果 var 是非空或非零的值，则 empty() 返回 FALSE。换句话说，””、0、”0”、NULL、FALSE、array()、var $var; 以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE。注意：empty() 只检测变量，检测任何非变量的东西都将导致解析错误。换句话说，后边的语句将不会起作用;</p><p>2、isset函数</p><p>用途：检测变量是否设置</p><p>判断：检测变量是否设置，并且不是 NULL。如果已经使用 unset() 释放了一个变量之后，它将不再是 isset()。若使用 isset() 测试一个被设置成 NULL 的变量，将返回 FALSE。同时要注意的是一个NULL 字节（”\0”）并不等同于 PHP 的 NULL 常数。</p></blockquote><h2 id="七、Ajax模块"><a href="#七、Ajax模块" class="headerlink" title="七、Ajax模块"></a>七、Ajax模块</h2><h3 id="基础部分-6"><a href="#基础部分-6" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>ajax是什么？</p><p>答：</p><blockquote><p>Ajax并不算是一种新的技术，全称是asychronous javascript and xml，可以说是已有技术的组合，主要用来实现客户端与服务器端的异步通信效果，实现页面的局部刷新，早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持</p><p>使用ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果</p></blockquote></li><li><p>同步和异步执行代码的区别？</p><p>答：</p><blockquote><p>同步：阻塞的</p><p>=张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭</p><p>=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面</p><p>异步：非阻塞的</p><p>=张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃</p><p>=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新</p></blockquote></li><li><p>页面编码和被请求的资源编码不一样如何处理？</p><p>答：</p><blockquote><p>对于ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 encodeURIComponent函数对参数进行编码处理，后台开发语言都有相应的解码api。对于post请求不需要进行编码</p></blockquote></li><li><p>简述ajax的过程？</p><p>答：</p><blockquote><ol><li>创建XMLHttpRequest对象,也就是创建一个异步调用对象</li><li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</li><li>设置响应HTTP请求状态变化的函数</li><li>发送HTTP请求</li><li>获取异步调用返回的数据</li><li>使用JavaScript和DOM实现局部刷新</li></ol></blockquote></li><li><p>请解释一下JavaScript的同源策略？</p><p>答：</p><blockquote><p>同源策略在什么情况下会起作用呢？ 当web 页面使用多个<iframe>元素或者打开其他浏览器窗口的时候，这一策略就 会起作用。<br>同源策略的含义： 脚本只能读取和所属文档来源相同的窗口和文档的属性。 这里就涉及到了一个浏览器如何判断两者是否同源以及如何判断脚本来源的问题。<br>注意一点：脚本本身的来源并不作为判断是否同源的依据，而是将脚本所属文档的来源 作为判断依据。</iframe></p><ol><li>判断脚本来源 例如：文档 A中通过 script 的 src引用了一个外部脚本，这个脚本是 google 提供的，也是从google 的主机上加载到文档 A中的，那么这个脚本的所属文档是谁呢， 答案是文档A。 </li><li>判断是否同源 理解了脚本来源，接着理解怎么判断是否同源：如果两个文档在协议、主机以 及载入文档的 URL端口这三点中有一点不同，就认为他们不同源。</li></ol></blockquote></li><li><p>get和post的区别？</p><p>答：</p><blockquote><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符</p><p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制</p><p>在以下情况中，请使用 POST 请求：</p><ol><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比GET 更稳定也更可靠</li></ol></blockquote></li><li><p>解释jsonp的原理？</p><p>答：</p><blockquote><p>Jsonp并不是一种数据格式，而json是一种数据格式，jsonp是用来解决跨域获取数据的一种解决方案，具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数，本质上使用的并不是ajax技术</p></blockquote></li><li><p>ajax请求时如何解释json数据？</p><p>答：</p><blockquote><p>使用eval() 或者JSON.parse() 鉴于安全性考虑，推荐使用JSON.parse()更靠谱，对数据的安全性更好。</p></blockquote></li><li><p>HTTP状态码都有哪些？</p><p>答：</p><blockquote><p>100 =&gt; 正在初始化（一般是看不到的）</p><p>101 =&gt; 正在切换协议（websocket浏览器提供的）</p><p>200或者以2开头的两位数 =&gt; 都是代表响应主体的内容已经成功返回了</p><p>202 =&gt; 表示接受</p><p>301 =&gt; 永久重定向/永久转移</p><p>302 =&gt; 临时重定向/临时转移（一般用来做服务器负载均衡）</p><p>304 =&gt; 本次获取的内容是读取缓存中的数据，会每次去服务器校验</p><p>400 =&gt; 参数出现错误（客户端传递给服务器端的参数出现错误）</p><p>401 =&gt; 未认证，没有登录网站</p><p>403 =&gt; 禁止访问，没有权限</p><p>404 =&gt; 客户端访问的地址不存在</p><p>500 =&gt; 未知的服务器错误</p><p>503 =&gt; 服务器超负荷（假设一台服务器只能承受10000人，当第10001人访问的时候，如果服务器没有做负载均衡，那么这个人的网络状态码就是503）</p></blockquote></li></ol><h3 id="实际工作部分-5"><a href="#实际工作部分-5" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>浏览器渲染页面的过程</p><p>答：</p><blockquote><p>浏览器会把HTML、SVG、XHTML三种格式的文件会产生一个DOM树；</p><p>Css，解析css会产生css规则树JavaScript会通过DOM apI 来操作DOM树 和 css规则树</p></blockquote></li><li><p>简单描述下同步和异步的区别，并举例实际应用中哪些是同步，哪些是异步？</p><p>答：</p><blockquote><p>同步是阻塞的，浏览器向服务器发送请求，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，页面才可以正常显示；</p><p>异步是非阻塞的，浏览器向服务器请求数据，服务器比较忙，浏览器可以干自己原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新。</p></blockquote></li><li><p>简述AJAX的工作原理</p><p>答：</p><blockquote><p>Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。</p><p>XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。</p></blockquote></li><li><p>jsonp是如何实现前后数据交互？</p><p>答：</p><blockquote><p>ajax请求受同源策略的影响，不允许进行跨域请求，而script标签的src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不在返回json格式的数据，而是返回调用某个函数的js代码，在src中进行了调用，这样就实现了跨域，其原理就是动态创建script标签，通过script标签的src属性进行调用</p></blockquote></li><li><p>你知道的HTTP 请求方式有几种？</p><p>答：</p><blockquote><p>HTTPRequestMethod共计17种</p><ol><li><strong>GET      请求指定的页面信息，并返回实体主体。</strong></li><li><strong>HEAD     类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头</strong></li><li><strong>POST     向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。</strong></li><li><strong>PUT      从客户端向服务器传送的数据取代指定的文档的内容。</strong></li><li><strong>DELETE   请求服务器删除指定的页面。</strong></li><li>CONNECT  HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS  允许客户端查看服务器的性能。</li><li>TRACE    回显服务器收到的请求，主要用于测试或诊断。</li><li>PATCH    实体中包含一个表，表中说明与该URI所表示的原内容的区别。</li><li>MOVE    请求服务器将指定的页面移至另一个网络地址。</li><li>COPY    请求服务器将指定的页面拷贝至另一个网络地址。</li><li>LINK    请求服务器建立链接关系。</li><li>UNLINK  断开链接关系。</li><li>WRAPPED 允许客户端发送经过封装的请求。</li><li>LOCK    允许用户锁定资源，比如可以再编辑某个资源时将其锁定，以防别人同时对其进行编辑。</li><li>MKCOL   允许用户创建资源</li><li>Extension-mothed    在不改动协议的前提下，可增加另外的方法。</li></ol></blockquote></li></ol><h2 id="八、H5C3模块"><a href="#八、H5C3模块" class="headerlink" title="八、H5C3模块"></a>八、H5C3模块</h2><h3 id="基础部分-7"><a href="#基础部分-7" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>CSS3有哪些新特性？</p><p>答：</p><blockquote><ol><li>CSS3实现圆角（border-radius），阴影（box-shadow），</li><li>对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）</li><li>transform:rotate(9deg)scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩  放,定位,倾斜</li><li>增加了更多的CSS选择器  多背景rgba </li><li>在CSS3中唯一引入的伪元素是 ::selection.</li><li>媒体查询，多栏布局</li><li>border-image</li></ol></blockquote></li><li><p>Html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML和HTML5？</p><p>答：</p><blockquote><p>新特性：</p><ol><li>拖拽释放(Drag and drop) API </li><li>语义化更好的内容标签（header,nav,footer,aside,article,section）</li><li>音频、视频API(audio,video)</li><li>画布(Canvas) API</li><li>地理(Geolocation) API</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>表单控件，calendar、date、time、email、url、search </li><li>新的技术webworker, websocket,Geolocation</li></ol><p>移除的元素：</p><ol><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u；</li><li>对可用性产生负面影响的元素：frame，frameset，noframes；</li></ol><p>支持HTML5新标签：</p><ol><li><p>IE8/IE7/IE6支持通过 document.createElement 方法产生的标签，可以利用这一特性让这些浏览器支持 HTML5 新标签，浏览器支持新标签后，还需要添加标签默认的样式（当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架）：</p><p><code>&lt;!--[if lt IE 9]&gt;</code></p><p><code>&lt;script&gt;src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt;</code></p><p><code>&lt;![endif]--&gt;</code></p></li></ol></blockquote></li><li><p>本地存储（Local Storage）和cookies（储存在用户本地终端上的数据）之间的区别是什么？</p><p>答：</p><blockquote><p>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；</p><p>本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除</p></blockquote></li><li><p>如何实现浏览器内多个标签页之间的通信?</p><p>答：</p><blockquote><p>调用 localstorge、cookies 等本地存储方式</p></blockquote></li><li><p>你如何对网站的文件和资源进行优化？</p><p>答：</p><blockquote><p>文件合并</p><p>文件最小化/文件压缩</p><p>使用CDN托管</p><p>缓存的使用</p></blockquote></li><li><p>什么是响应式设计？</p><p>答：</p><blockquote><p>它是关于网页制作的过程中让不同的设备有不同的尺寸和不同的功能。响应式设计是让所有的人能在这些设备上让网站运行正常  </p></blockquote></li><li><p>新的 HTML5文档类型和字符集是</p><p>答：</p><blockquote><p>HTML5文档类型：<!doctype html></p><p>HTML5使用的编码<meta charset="”UTF-8”"></p></blockquote></li><li><p>HTML5 Canvas元素有什么用？</p><p>答：</p><blockquote><p>Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在HTML 上进行图形操作。</p></blockquote></li><li><p>HTML5 存储类型有什么区别？</p><p>答：</p><blockquote><p>Media API、Text Track API、Application Cache API、User Interaction、Data Transfer API、Command API、Constraint Validation API、History API</p></blockquote></li><li><p>CSS3新增伪类有那些？</p><p>答：</p><blockquote><p>   p:first-of-type 选择属于其父元素的首个 </p><p> 元素的每个 </p><p> 元素。</p><p>   p:last-of-type  选择属于其父元素的最后 </p><p> 元素的每个 </p><p> 元素。</p><p> p:only-of-type  选择属于其父元素唯一的 </p><p> 元素的每个 </p><p> 元素。</p><p>   p:only-child    选择属于其父元素的唯一子元素的每个 </p><p> 元素。</p><p>  p:nth-child(2)  选择属于其父元素的第二个子元素的每个 </p><p> 元素。</p><p>  :enabled、:disabled 控制表单控件的禁用状态。</p><p>  :checked，单选框或复选框被选中。</p></blockquote></li><li><p>你怎么来实现页面设计图，你认为前端应该如何高质量完成工作?一个满屏品 字布局 如何设计?</p><p>答：</p><blockquote><p>  首先划分成头部、body、脚部；。。。。。</p><p>  实现效果图是最基本的工作，精确到2px；</p><p>  与设计师，产品经理的沟通和项目的参与</p><p>  做好的页面结构，页面重构和用户体验</p><p>  处理hack，兼容、写出优美的代码格式</p><p>  针对服务器的优化、拥抱 HTML5。</p></blockquote></li><li><p>为什么利用多个域名来存储网站资源会更有效？</p><p>答：</p><blockquote><p>  CDN缓存更方便 </p><p>  突破浏览器并发限制 </p><p>  节约cookie带宽 </p><p>  节约主域名的连接数，优化页面响应速度 </p><p>  防止不必要的安全问题</p></blockquote></li><li><p>请谈一下你对网页标准和标准制定机构重要性的理解。</p><p>答：</p><blockquote><p>（无标准答案）网页标准和标准制定机构都是为了能让web发展的更‘健康’，开发者遵循统一的标准，降低开发难度，开发成本，SEO也会更好做，也不会因为滥用代码导致各种BUG、安全问题，最终提高网站易用性。</p></blockquote></li><li></li></ol><h3 id="实际工作部分-6"><a href="#实际工作部分-6" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>请描述一下cookies]()，sessionStorage和localStorage的区别？</p><p>答：</p><blockquote><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p><p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p></blockquote></li><li><p>如何在 HTML5页面中嵌入视频？</p><p>答：</p><blockquote><p>HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg;</p><p><code>&lt;video&gt;</code></p><p><code>&lt;source src=&quot;jamshed.mp4&quot; type=&quot;video/mp4&quot;&gt;</code></p><p><code>Your browser does&#39;nt support video embedding feature.</code></p><p><code>&lt;/video&gt;</code></p></blockquote></li><li><p>HTML5引入什么新的表单属性？</p><p>答：</p><blockquote><p>Datalist   datetime  output   keygen  date month  week  time number   range   emailurl</p></blockquote></li></ol><h2 id="九、Node模块"><a href="#九、Node模块" class="headerlink" title="九、Node模块"></a>九、Node模块</h2><h3 id="基础部分-8"><a href="#基础部分-8" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>对Node的优点和缺点提出了自己的看法</p><p>答：</p><blockquote><p>（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，</p><p> 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。</p><p> 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，</p><p> 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。</p><p>（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，</p><p>而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子</p></blockquote></li><li><p>node.js 的应用场景</p><p>答：</p><blockquote><ol><li>实时应用：如在线聊天，实时通知推送等等（如socket.io）</li><li>分布式应用：通过高效的并行I/O使用已有的数据</li><li>工具类应用：海量的工具，小到前端压缩部署（如grunt），大到桌面图形界面应用程序</li><li>游戏类应用：游戏领域对实时和并发有很高的要求（如网易的pomelo框架）</li><li>利用稳定接口提升Web渲染能力</li><li>前后端编程语言环境统一：前端开发人员可以非常快速地切入到服务器端的开发（如著名的纯Javascript全栈式MEAN架构）</li></ol></blockquote></li><li><p>NodeJS非阻塞I/O模型执行流程</p><p>答：</p><blockquote><p>主线程：</p><ol><li><p>执行 node 的代码，把代码放入队列</p></li><li><p>事件循环程序（主线程）把队列里面的同步代码都先执行了，</p></li><li><p>同步代码执行完成，执行异步代码</p></li><li><p>异步代码分 2种状况，</p><p>(1)、异步非 io setTimeout() setInterval()</p><p>判断是否可执行，如果可以执行就执行，不可以跳过。</p><p>(2)、异步io 文件操作</p><p>会从线程池当中去取一条线程，帮助主线程去执行。</p></li><li><p>主线程会一直轮训，队列中没有代码了，主线程就会退出。</p></li></ol><p>子线程：被放在线程池里面的线程，用来执行异步 io操作</p><ol><li><p>在线程池里休息</p></li><li><p>异步 io 的操作来了，执行异步 io操作。</p></li><li><p>子线程会把异步 io操作的 callback 函数，扔回给队列</p></li><li><p>子线程会回到线程池了去休息。</p><p>callback，在异步 io 代码执行完成的时候被扔回主线程。</p></li></ol></blockquote></li><li><p>nodejs中流(stream)的理解</p><p>答：</p><blockquote><ol><li>什么是Stream?<br>答案:stream是基于事件EventEmitter的数据管理模式．由各种不同的抽象接口组成，<br>主要包括可写，可读，可读写，可转换等几种类型．</li><li>Stream有什么好处?<br>答案: 非阻塞式数据处理提升效率，片断处理节省内存，管道处理方便可扩展等.</li><li>Stream有哪些典型应用?<br>答案: 文件，网络，数据转换，音频视频等.<ol><li>怎么捕获 Stream的错误事件?<br>答案: 监听 error 事件，方法同 EventEmitter.</li><li>有哪些常用Stream,分别什么时候使用?<br>答案:Readable 为可被读流，在作为输入数据源时使用；Writable 为可被写流,在作为<br>输出源时使用；Duplex 为可读写流,它作为输出源接受被写入，同时又作为输入源被后面的<br>流读出．Transform 机制和Duplex一样，都是双向流，区别时 Transfrom 只需要实现一<br>个函数_transfrom(chunk, encoding, callback);而 Duplex 需要分别实现_read(size)函数<br>和_write(chunk, encoding, callback)函数.</li><li>实现一个 Writable Stream?<br>答案: 三步走:1)构造函数call Writable 2) 继承 Writable 3) 实现_write(chunk,<br>encoding, callback)函数</li></ol></li></ol></blockquote></li><li><p>ES6有哪些新特性?</p><p>答：</p><blockquote><p>类的支持，模块化，箭头操作符，let/const块作用域，字符串模板，解构，参数默认值/不定参数/拓展参数, for-of遍历, generator, Map/Set, Promise</p></blockquote></li><li><p>你对ES6的个人看法</p><p>答：</p></li></ol><blockquote><p>从软件工程角度来看，以前真的很弱，不适合做大型应用，很容易导致烂尾工程。ES6就相当于当年的Java5,是历史性的发展，从此我们可以用js做大型项目了。事实上，各大主流浏览器现在已经支持大部分新特性了，后端的Node.js更是可以直接使用ES6的绝大多数语法。</p></blockquote><ol start="7"><li><p>node中的Buffer如何应用?</p><p>答：</p><blockquote><p>Buffer是用来处理二进制数据的，比如图片，mp3,数据库文件等.Buffer支持各种编码解码，二进制字符串互转．</p></blockquote></li><li><p>什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点?</p><p>答：</p><blockquote><ol><li><p>什么是前端路由</p><p> 路由是根据不同的url地址展示不同的内容或页面。前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前通过服务端根据url的不同返回不同的页面实现的</p></li><li><p>什么时候使用前端路由</p><p>在单页面应用，大部分页面结构不变，只改变部分内容的使用</p></li><li><p>前端路由有什么优缺点</p><p>优点：</p><p>​         用户体验好，不需要每次都从服务器全部获取，快速展现给用户</p><p>缺点：</p><p>​         使用浏览器的前进，后退键的时候会重新发送请求，没有合理利用缓存</p><p>​         单页面无法记住之前滚动的位置，无法再前进，后退的时候记住滚动的</p></li></ol></blockquote></li><li><p>如何判断当前脚本运行在浏览器还是node环境中？</p><p>答：</p><blockquote><p>  exports    =    typeof    window    ===        ‘undefined’      ?    global    :    window  ;</p><p>  获取全局对象的方式</p><p>  同理可得，typeof window可以用来判断是不是在浏览器环境中</p></blockquote></li></ol><h3 id="实际工作部分-7"><a href="#实际工作部分-7" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>node中的异步和同步怎么理解?</p><p>答：</p><blockquote><p>node是单线程的，异步是通过一次次的循环事件队列来实现的．同步则是说阻塞式的IO,这在高并发环境会是一个很大的性能问题，所以同步一般只在基础框架的启动时使用，用来加载配置文件，初始化程序什么的．</p></blockquote></li><li><p>有哪些方法可以进行异步流程的控制?</p><p>答：</p><blockquote><ol><li>多层嵌套回调 </li><li>为每一个回调写单独的函数，函数里边再回调 </li><li>用第三方框架比方async, q, promise等</li></ol></blockquote></li><li><p>npm有哪些常用的命令，请列举并说明作用</p><p>答：</p><blockquote><p><code>$npm init</code>                项目初始化</p><p><code>$npminstall -g &lt;name&gt;</code>   安装并更新package.json中的版本配置</p><p><code>$npm run&lt;name&gt;</code>        执行一段脚本</p><p><code>$npm update -n &lt;name&gt;</code>   更新模块</p></blockquote></li></ol><h2 id="十、VUE模块"><a href="#十、VUE模块" class="headerlink" title="十、VUE模块"></a>十、VUE模块</h2><h3 id="基础部分-9"><a href="#基础部分-9" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>Vue组件间传值</p><p>答：</p><blockquote><ol><li><p>父子之间的传值</p><p>父组件向子组件传值<strong>通过prop</strong>子组件在props中创建一个属性，用以接收父组件传过来的值 </p><p>子组件向父组件传值在响应该点击事件的函数中使用$emit来触发一个自定义事件在父组件中注册子组件并在子组件标签上绑定对自定义事件的监听</p></li><li><p>非父子之间的通讯</p><p>可以通过eventBus来实现通信. </p><p>所谓eventBus就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件</p><p>eventBus = new Vue();</p><p>组件1触发：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &lt;div @click=<span class="string">"eve"</span>&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    methods: &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">        <span class="function"><span class="title">eve</span></span>() &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">            eventBus.<span class="variable">$emit</span>(<span class="string">'change'</span>,<span class="string">'hehe'</span>); //Hub触发事件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">        &#125;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &#125;123456</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure></li></ol></blockquote><pre><code>&gt;&gt;    组件2接收:&gt;&gt;    <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">    &lt;div&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    <span class="function"><span class="title">created</span></span>() &#123;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">        eventBus.<span class="variable">$on</span>(<span class="string">'change'</span>, () =&gt; &#123; //Hub接收事件</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">            this.msg = <span class="string">'hehe'</span>;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">        &#125;);</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">    &#125;123456</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>&gt;&gt;    这样就实现了非父子组件之间的通信了.原理就是把eventBus当作一个中转站！</code></pre></li><li><p>VUE是什么?</p><p>答：</p><blockquote><p>vue.js（读音 /vjuː/，类似于 view） 是一套构建用户界面的渐进式框架<br>与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视<br>图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与单文件组件<br>和 Vue 生态系统支持的库结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。</p></blockquote></li><li><p>React 和 Vue 的区别React 和 Vue 的相似之处：</p><p>答：</p><blockquote><ol><li>使用 Virtual DOM</li><li>提供了响应式（Reactive）和组件化（Composable）的视图组件。</li><li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li></ol><p>Vue与Angular、React的对比：</p><ol><li>vue.js 更轻量，gzip后只有20K+，angular:56K ,react:44K</li><li>vue.js 更易上手，学习曲线平稳</li><li>吸收两家之长，有angular 的指令和 react组件化思想</li></ol><p>优缺点：</p><p>优点：体积小。接口灵活。侵入性好，可用于页面的一部分，而不是整个页面。扩展性好。源码规范简洁。代码较为活跃，作者是中国人，可在官方论坛中文提问。github9000+。基于组件化的开发。它是一个轻量级 mvvm框架、数据驱动+组件化的前端开发、社区完善</p><p>缺点：社区不大，如果有问题可以读源码。功能仅限于view 层，Ajax等功能需要额外的库。对开发人员要求较高。开发的话，需要 webpack，不然很难用，最好配合es6。</p></blockquote></li><li><p>v-show 和 v-if的选择</p><p>答：</p><blockquote><p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。</p><p>相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。</p></blockquote></li><li><p>Vue.js核心思想</p><p>答：</p><blockquote><p>Vue.js是一个提供MVVM数据双向绑定的库，专注于UI层面，核心思想是：数据驱动、组件系统。</p><p><strong>数据驱动：</strong></p><p>Vue.js数据观测原理在技术实现上，利用的是ES5Object.defineProperty和存储器属性: getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。</p><p>组件式编程</p></blockquote></li><li><p>template参数选项的有无对生命周期的影响</p><p>答：</p><blockquote><ol><li>如果Vue实例对象中有template参数选项，则将其作为模板编译成render函数</li><li>如果没有template参数选项，则将外部的HTML作为模板编译（template），也就是说，template参数选项的优先级要比外部的HTML高</li><li>如果1,2条件都不具备，则报错</li></ol></blockquote></li></ol><h3 id="实际工作部分-8"><a href="#实际工作部分-8" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>怎么定义vue-router的动态路由？怎么获取传过来的动态参数？</p><p>答：</p><blockquote><p>对path属性加上/:id。  使用router对象的params.id</p></blockquote></li><li><p>vue-router有哪几种导航钩子</p><p>答：</p><blockquote><ol><li><p>vue-router 提供的导航钩子主要用来拦截导航，让它完成跳转或取消</p><p>三种：</p></li></ol><p>第一种是全局导航钩子：router.beforeEach(to,from,next)，作用：跳转前进行判断拦截。</p><p>第二种：组件内的钩子；</p><p>第三种：单独路由独享组件</p></blockquote></li><li><p>说出至少4种vue当中的指令和它的用法？</p><p>答：</p><blockquote><p> v-if：判断是否隐藏；</p><p> v-for：数据循环出来；</p><p> v-bind:class：绑定一个属性；</p><p> v-model：实现双向绑定</p></blockquote></li><li><p>8、简述一些vue项目中文件构成？</p><p>答：</p><blockquote><p>build文件夹：主要就是webpack的配置；</p><p>Config文件夹：主要的就是index.js 这个文件进行配置代理服务器</p><p>Src文件夹：</p><p> “assets”共用的样式和图片</p><p> “components”业务代码存放</p><p> “router”路由</p><p> “APP.vue”vue 文件入口界面</p><p>“main.js”对应App.vue创建的实例，也是入口文件，对应     webpack.base.config.js里的入口配置<br>Static文件夹：静态资源<br>Pack.json:scripts 里面设置命令，例如设置了dev用于调试则我们开发时输入的是npm run dev ；例如设置了build 则是输入 npm run build 用于打包;另一部分是这里可以看到我们需要的依赖包,在dependencies和devDependencies中，分别对应全局下载和局部下载的依赖包</p></blockquote></li></ol><h2 id="十一、Angular和React模块"><a href="#十一、Angular和React模块" class="headerlink" title="十一、Angular和React模块"></a>十一、Angular和React模块</h2><h3 id="基础部分-10"><a href="#基础部分-10" class="headerlink" title="基础部分"></a>基础部分</h3><ol><li><p>angularJS是什么?</p><p>答：</p><blockquote><p>AngularJS 是一个 JavaScript 框架。它可通过 <script> 标签添加到 HTML 页面。</p><p>AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML</p></blockquote></li><li><p>angularJS中的MVVM模式</p><p>答：</p><blockquote><p>采用这种方式为合理组织代码提供了方便，降低了代码间的耦合度，功能结构清晰可见。<br>Model：一般用来处理数据，包括读取和设置数据，一般指的是操作数据库。<br>View：一般用来展示数据，就是放数据，比如通过 HTML来展示。<br>Controller：因为一个模块里面可能有多个视图和模型，控制器就起到了连接模型和视图的<br>作用。<br>VM--> ViewModel（视图模型） 也就是$scope。<br>MVC 模式在AngularJS 中的体现：<br>一、首先定义应用，采用ng-app属性指定一个应用，表示此标签内所包裹的内容都属于<br>APP的一部分。<br><code>&lt;html ng-app=&quot;App&quot; lang=&quot;en&quot;&gt;</code></p></blockquote></li><li><p>模块化与依赖注入</p><p>答：</p><blockquote><p>AngularJS 模块：<br>AngularJS模块是一种容器，把代码隔离并组织成简洁，整齐，可复用的块。<br>模块本身不提供直接的功能：包含其他提供功能的对象的实例：控制器，过滤器，服务，动<br>画。可通过定义其提供的对象构建模块。通过依赖注入将模块连接在一起，构建一个完整的<br>应用程序。<br>AngularJS建立在模块原理上。大部分 AngularJS 提供的功能都内置到ng-*模块中。</p><p>创建模块：<br>你可以通过 AngularJS 的 angular.module 函数来创建模块：<br><code>&lt;div ng-app=&quot;myApp&quot;&gt;...&lt;/div&gt;</code><br><code>&lt;script&gt;</code><br><code>var app = angular.module(&quot;myApp&quot;, []);</code></p><p><code>&lt;/script&gt;</code><br>依赖注入：（Dependency Injection，简称 DI）是一种软件设计模式，在这种模式下，一<br>个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，<br>然后成为了该客户端状态的一部分。<br>该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转<br>和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用<br>该系统找到依赖<br>一句话 ，没事你不要来找我，有事我会去找你。<br>AngularJS 提供很好的依赖注入机制。以下 5个核心组件用来作为依赖注入：value、<br>factory、service、provider、constant</p></blockquote></li><li><p>ReactJS的适用场景</p><p>答：</p><blockquote><p>一些后台界面，或者是和后台数据比较多，又或者和用户交互比较多，dom 操作频繁的<br>都可以用 react。因为 react 的大特点就是虚拟DOM 技术，这样可以提高渲染的性能。个<br>人的体验就是，用 react可以让整个页面的速度提高很多。<br>另外这样做的话，和后台的数据通过接口来进行前后端分离，也挺好挺方便的</p></blockquote></li><li><p>ReactJS是什么</p><p>答：</p><blockquote><p>React 是一个用于构建用户界面的 JAVASCRIPT 库。<br>React主要用于构建 UI，很多人认为 React 是 MVC 中的 V（视图）。<br>React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月<br>开源。<br>React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。</p></blockquote></li><li><p>ReactJs 的特点</p><p>答：</p><blockquote><ol><li>声明式设计 −React 采用声明范式，可以轻松描述应用。</li><li>高效 −React通过对 DOM 的模拟，最大限度地减少与 DOM 的交互。</li><li>灵活 −React可以与已知的库或框架很好地配合。</li><li>JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。</li></ol><ol start="5"><li>组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。</li></ol><ol start="6"><li>单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。</li></ol></blockquote></li><li><p>react Native比起标准Web开发或原生开发能够带来的三大好处</p><p>答：</p><blockquote><ol><li>手势识别：基于Web 技术（HTML5/JavaScript）构建的移动应用经常被抱怨缺乏及时响应。而基于原生 UI的React Native能避免这些问题从而实现实时响应。</li></ol><ol start="2"><li>原生组件：使用 HTML5/JavaScript 实现的组件比起原生组件总是让人感觉差一截，而React Native 由于采用了原生UI组件自然没有此问题。</li></ol><ol start="3"><li>样式和布局：iOS、Android 和基于Web 的应用各自有不同的样式和布局机制。React Native 通过一个基于 FlexBox的布局引擎在所有移动平台上实现了一致的跨平台样式和布局方案。</li></ol></blockquote></li></ol><h3 id="实际工作部分-9"><a href="#实际工作部分-9" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>看过Angular的源码吗，它是怎么实现双向数据绑定的?</p><p>答：</p><blockquote><p>angular对常用的dom事件， xhr事件等做了封装，在里面触发进入angular的digest 流程。 在digest 流程里面， 会从 rootscope 开始遍历， 检查所有的watcher</p></blockquote></li><li><p>为什么angular不推荐使用dom操作？</p><p>答：</p><blockquote><p>Angular 倡导以测试驱动开发，在的 service 或者 controller 中出现了DOM 操作，那 么也就意味着的测试是无法通过的 使用 Angular 的其中一个好处是啥，那就是双向数据绑定，这样就能专注于处理业务逻辑， 无需关系一堆堆的 DOM 操作。如果在 Angular 的代码中还到处充斥着各种 DOM 操作， 那为什么不直接使用jquery 去开发呢。</p></blockquote></li><li><p>MVC模式的意思是，软件可以分成三个部分？</p><p>答：</p><blockquote><p>视图（View）：用户界面。<br>控制器（Controller）：业务逻辑<br>模型（Model）：数据保存</p></blockquote></li><li><p>各部分之间的通信方式是什么？</p><p>答：</p><blockquote><p>View 传送指令到 Controller<br>Controller 完成业务逻辑后，要求 Model 改变状态<br>Model 将新的数据发送到 View，用户得到反馈</p></blockquote></li></ol><h2 id="十二、其他"><a href="#十二、其他" class="headerlink" title="十二、其他"></a>十二、其他</h2><h3 id="实际工作部分-10"><a href="#实际工作部分-10" class="headerlink" title="实际工作部分"></a>实际工作部分</h3><ol><li><p>webpack是怎样配置的，简要描述一下过程</p><p>答：</p><blockquote><p>第一在项目文件创建一个webpack.config.js文件，配置文件创建好了，第二开始正式配置webpack了，首先下载好node.js，因为webpack基于node.js,装好node.js后，通过命令行窗口找到项目文件，在项目文件webpack.config.js文件所在的目录下输入 npm install webpack -save dev  下载webpack依赖文件到本地项目中，下载好后会在webpack.config.js文件下自动创建node_modules文件夹，文件夹里就是所有项目中用到的依赖插件，现在只有一个webpack，项目中用到在下载！</p></blockquote></li><li><p>git的作用是什么，有哪些命令，这些命令的作用是什么？在pull时，如果只想要文件的一部分而不是工程文件的整个，使用什么命令？git的冲突如何解决？</p><p>答：</p><blockquote><p>git是一个开源的分布式版本控制系统，用以有效、高速处理很小到非常大的项目版本管理。</p><p>常用的命令：<br>git init   初始化仓库</p><p>git config --globaluser.name    配置用户名</p><p>git config --globaluser.email    配置邮箱</p><p>git add      文件添加到暂存区</p><p>git commit   文件添加到仓库</p><p>git branch    列出所有的分支</p><p>git status     显示有变更的文件</p><p>git log       查看当前分支的版本历史</p><p>git push      提交本地代码到远程</p><p>git pull       从远程仓库下载到本地</p><p>git checkout   创建切换分支</p><p>解决git分支冲突： 将本地dev删除,在重新checkout一个dev分支(保证了此时我们的本地dev分支是最新的),在进行pull服务器分支,就这样解决了.</p></blockquote></li><li><p>怎么防止内存泄露？</p><p>答：</p><blockquote><ol><li>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收</li><li>注意程序逻辑，避免“死循环”之类的</li><li>避免创建过多的对象 。</li></ol></blockquote></li><li><p>网站优化时怎么做数据分析？</p><p>答：</p><blockquote><p>网站优化时，我们需要每天在百度统计中查看我们网站的每日流量，还有在各大站长平台中查看网站的收录量，网站关键词流量，还有就是每天要用站长工具查看网站的基本情况。这些数据都是最基础的。</p></blockquote></li></ol></script></p></blockquote></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 复习二 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>复习1</title>
      <link href="/2019/09/20/%E5%A4%8D%E4%B9%A01/"/>
      <content type="html"><![CDATA[<p>复习整理一</p><a id="more"></a><h2 id="一、前端和计算机相关知识"><a href="#一、前端和计算机相关知识" class="headerlink" title="一、前端和计算机相关知识"></a>一、前端和计算机相关知识</h2><h3 id="1-你能描述一下渐进增强和优雅降级之间的不同吗"><a href="#1-你能描述一下渐进增强和优雅降级之间的不同吗" class="headerlink" title="1. 你能描述一下渐进增强和优雅降级之间的不同吗?"></a>1. 你能描述一下渐进增强和优雅降级之间的不同吗?</h3><ul><li>定义:<ul><li>优雅降级（graceful degradation）: 一开始就构建站点的完整功能，然后针对浏览器测试和修复</li><li>渐进增强（progressive enhancement）: 一开始只构建站点的最少特性，然后不断针对各浏览器追加功能。 </li></ul></li><li>都关注于同一网站在不同设备里不同浏览器下的表现程度</li><li>区别:<ul><li>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站. 而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。</li><li>“渐进增强”观点则认为应关注于内容本身。请注意其中的差别：我甚至连“浏览器”三个字都没提。</li></ul></li><li>理解:<ul><li>“优雅降级”就是首先完整地实现整个网站,包括其中的功能和效果. 然后再为那些无法支持所有功能的浏览器增加候选方案, 使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</li><li>“渐进增强”则是从浏览器支持的基本功能开始, 首先为所有设备准备好清晰且语义化的html及完整内容, 然后再以无侵入的方法向页面增加无害于基础浏览器的额外样式和功能. 当浏览器升级时, 它们会自动呈现并发挥作用.</li></ul></li></ul><h3 id="2-浏览器兼容问题"><a href="#2-浏览器兼容问题" class="headerlink" title="2. 浏览器兼容问题:"></a>2. 浏览器兼容问题:</h3><h5 id="2-1不同浏览器的标签默认的外补丁和内补丁不同"><a href="#2-1不同浏览器的标签默认的外补丁和内补丁不同" class="headerlink" title="2.1不同浏览器的标签默认的外补丁和内补丁不同."></a>2.1不同浏览器的标签默认的外补丁和内补丁不同.</h5><ul><li><p>即随便写几个标签, 在不加样式控制的情况下, 各自的margin和padding差异较大.</p></li><li><p>解决方法: CCS里:   *{margin:0; padding:0}</p><h5 id="2-2块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大"><a href="#2-2块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大" class="headerlink" title="2.2块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大"></a>2.2块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大</h5></li><li><p>会使得ie6后面的一块被顶到下一行.</p></li><li><p>在float的标签样式中加入 display: inline; 将其转化为行内属性</p><h5 id="2-3设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度"><a href="#2-3设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度" class="headerlink" title="2.3设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度"></a>2.3设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度</h5></li><li><p>IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度</p></li><li><p>解决方案: 给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度</p></li><li><p>原因: ie8之前的浏览器都会给标签一个最小默认的行高的高度. 即使标签是空的,这个标签的高度还是会达到默认的行高.</p><h5 id="2-4-行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，IE6间距bug"><a href="#2-4-行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，IE6间距bug" class="headerlink" title="2.4 行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug"></a>2.4 行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug</h5></li><li><p>解决: 在display:block;后面加入display:inline;display:table;</p><h5 id="2-5-图片默认有间距"><a href="#2-5-图片默认有间距" class="headerlink" title="2.5 图片默认有间距"></a>2.5 图片默认有间距</h5></li><li><p>几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。</p></li><li><p>解决: 使用float属性为img布局</p><h5 id="2-6-标签最低高度设置min-height不兼容"><a href="#2-6-标签最低高度设置min-height不兼容" class="headerlink" title="2.6 标签最低高度设置min-height不兼容"></a>2.6 标签最低高度设置min-height不兼容</h5></li><li><p>因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容</p></li><li><p>如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}</p><h5 id="2-7-透明度的兼容CSS设置"><a href="#2-7-透明度的兼容CSS设置" class="headerlink" title="2.7 透明度的兼容CSS设置"></a>2.7 透明度的兼容CSS设置</h5></li><li><p>使用hacker</p></li><li><p>IE6认识的hacker是下划线_和*</p></li><li><p>IE7,遨游认识的hacker是*</p><h5 id="2-8-IE-ol的序号全为1-不递增"><a href="#2-8-IE-ol的序号全为1-不递增" class="headerlink" title="2.8 IE ol的序号全为1, 不递增"></a>2.8 IE ol的序号全为1, 不递增</h5></li><li><p>解决: li设置样式{display: list-item}</p><h5 id="2-9-ie6-7不支持display-inline-block"><a href="#2-9-ie6-7不支持display-inline-block" class="headerlink" title="2.9 ie6,7不支持display:inline-block"></a>2.9 ie6,7不支持display:inline-block</h5></li><li><p>解决方法: 设置inline并触法haslayout</p></li><li><p>display:inline-block; *display:inline; *zoom:1 </p></li></ul><h3 id="3-如何对网站的文件和资源进行优化"><a href="#3-如何对网站的文件和资源进行优化" class="headerlink" title="3. 如何对网站的文件和资源进行优化?"></a>3. 如何对网站的文件和资源进行优化?</h3><ul><li>文件合并（同上题“假若你有5个不同的 CSS 文件, 加载进页面的最好方式是？”）<ul><li>减少调用其他页面、文件的数量。一般我们为了让页面生动活泼会大量使用background来加载背景图，而每个 background的图像都会产生1次HTTP请求，要改善这个状况，可以采用css的1个有用的background-position属 性来加载背景图，我们将需要频繁加载的多个图片合成为1个单独的图片，需要加载时可以采用：background:url(….) no-repeat x-offset y-offset;的形式加载即可将这部分图片加载的HTTP请求缩减为1个。</li><li>每个http请求都会产生一次从你的浏览器到服务器端网络往返过程，并且导致推迟到达服务器端和返回浏览器端的时间，我们称之为延迟。</li></ul></li><li>文件最小化/文件压缩<ul><li>即将需要传输的内容压缩后传输到客户端再解压，这样在网络上传输的 数据量就会大幅减小。通常在服务器上的Apache、Nginx可以直接开启这个设置，也可以从代码角度直接设置传输文件头，增加gzip的设置，也可以 从 负载均衡设备直接设置。不过需要留意的是，这个设置会略微增加服务器的负担。建议服务器性能不是很好的网站，要慎重考虑。</li><li>js和css文件在百度上搜一个压缩网站就能压缩，但是在实际开发的项目中，使用gulp、webpack等工具可以打包出合并压缩后的文件，小图片可以在打包时转换成base64方式引入，大图片可以被压缩，html文件也是可以被压缩的</li></ul></li><li>使用 CDN 托管<ul><li>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</li></ul></li><li>缓存的使用<ul><li>Ajax调用都采用缓存调用方式，一般采用附加特征参数方式实现，注意其中的&lt;script src=”xxx.js?{VERHASH}”，{VERHASH}就是特征参数，这个参数不变化就使用缓存文件，如果发生变化则重新下载新文件或更新信息。</li></ul></li><li>css文件放置在head，js放置在文档尾</li><li>在服务器端配置control-cache  last-modify-date</li><li>在服务器配置Entity-Tag     if-none-match</li><li>用更少的时间下载更多的文件，提高网站加载速度，提高用户体验，可以使用以下方法：<ul><li>1.css sprites—-将小图片合并为一张大图片，使用background-position等css属性取得图片位置</li><li>2.将资源放在多个域名下—–打开控制台，可以看到很多网站都是这么做的~</li><li>3.图片延迟加载—–很多电商网站、新闻网站，尤其是用到瀑布流展示图片的时候，很多都这么做了，这个技术已经很普遍~</li></ul></li><li>书写代码的时候要注意优化： <ul><li>1.css<ul><li>将可以合并的样式合并起来，比如margin-top、margin-bottom等。</li><li>给img图片设置宽高，因为浏览器渲染元素的时候没有找到这两个参数，需要一边下载图片一边计算大小，如果图片很多，浏览器需要不断地调整页面。这不但影响速度，也影响浏览体验。当浏览器知道了高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容。从而加载时间快了，浏览体验也更好了。</li></ul></li><li>2.js<ul><li>少改变DOM元素，少触发reflow，可以复用的代码提出来写成公共的等等……</li></ul></li><li>3.img<ul><li>优化图片，不失真的情况下尽量减少图片大小，使用iconfont等<h3 id="4-关于前后端分离"><a href="#4-关于前后端分离" class="headerlink" title="4. 关于前后端分离:"></a>4. 关于前后端分离:</h3></li></ul></li></ul></li><li>前端：负责View和Controller层。</li><li>后端：只负责Model层，业务处理/数据等。<h3 id="5-关于浏览器内核-渲染引擎"><a href="#5-关于浏览器内核-渲染引擎" class="headerlink" title="5. 关于浏览器内核(渲染引擎)"></a>5. 关于浏览器内核(渲染引擎)</h3></li><li>先说一下浏览器的结构：<ul><li>①、用户界面（UI） - 包括菜单栏、工具栏、地址栏、后退/前进按钮、书签目录等，也就是能看到的除了显示页面的主窗口之外的部分；</li><li>②、浏览器引擎（Rendering engine） - 也被称为浏览器内核、渲染引擎，主要负责取得页面内容、整理信息（应用CSS）、计算页面的显示方式，然后会输出到显示器或者打印机；</li><li>③、JS解释器 - 也可以称为JS内核，主要负责处理javascript脚本程序，一般都会附带在浏览器之中，例如chrome的V8引擎；</li><li>④、网络部分 - 主要用于网络调用，例如：HTTP请求，其接口与平台无关，并为所有的平台提供底层实现；</li><li>⑤、UI后端 - 用于绘制基本的窗口部件，比如组合框和窗口等。</li><li>⑥、数据存储 - 保存类似于cookie、storage等数据部分，HTML5新增了web database技术，一种完整的轻量级客户端存储技术。</li><li>注：IE只为每个浏览器窗口启用单独的进程，而chrome浏览器却为每个tab页面单独启用进程，也就是每个tab都有独立的渲染引擎实例。</li></ul></li><li>现在的主要浏览器：<ul><li>IE、Firefox、Safari、Chrome、Opera。</li><li>它们的浏览器内核（渲染引擎）：<ul><li>IE–Trident、</li><li>FF(Mozilla)–Gecko、</li><li>Safari–Webkit、</li><li>Chrome–Blink（WebKit的分支）、</li><li>Opera–原为Presto，现为Blink。</li></ul></li><li>因此在开发中，兼容IE、FF、Opera（Presto引擎是逐步放弃的）、Chrome和Safari中的一种即可，Safari、Chrome的引擎是相似的。<h3 id="6-浏览器加载文件-repaint-reflow"><a href="#6-浏览器加载文件-repaint-reflow" class="headerlink" title="6.浏览器加载文件(repaint/reflow)"></a>6.浏览器加载文件(repaint/reflow)</h3></li></ul></li><li>文件加载顺序<ul><li>浏览器加载页面上引用的CSS、JS文件、图片时，是按顺序从上到下加载的，每个浏览器可以同时下载文件的个数不同，因此经常有网站将静态文件放在不同的域名下，这样可以加快网站打开的速度。</li></ul></li><li>reflow<ul><li>在加载JS文件时，浏览器会阻止页面的渲染，因此将js放在页面底部比较好。</li><li>因为如果JS文件中有修改DOM的地方，浏览器会倒回去把已经渲染过的元素重新渲染一遍，这个回退的过程叫reflow。</li><li>CSS文件虽然不影响js文件的加载，但是却影响js文件的执行，即使js文件内只有一行代码，也会造成阻塞。因为可能会有var width = $(‘#id’).width()这样的语句，这意味着，js代码执行前，浏览器必须保证css文件已下载和解析完成。</li><li>办法：当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。</li></ul></li><li>常见的能引起reflow的行为：<ul><li>1.改变窗囗大小</li><li>2.改变文字大小</li><li>3.添加/删除样式表</li><li>4.脚本操作DOM</li><li>5.设置style属性</li><li>等等……</li></ul></li><li>reflow是不可避免的，只能尽量减小，常用的方法有：<ul><li>1.尽量不用行内样式style属性，操作元素样式的时候用添加去掉class类的方式</li><li>2.给元素加动画的时候，可以把该元素的定位设置成absolute或者fixed，这样不会影响其他元素</li></ul></li><li>repaint<ul><li>另外，有个和reflow相似的术语，叫做repaint（重绘），在元素改变样式的时候触发，这个比reflow造成的影响要小，所以能触发repaint解决的时候就不要触发reflow……<h3 id="7-为什么利用多个域名来请求网络资源会更有效？"><a href="#7-为什么利用多个域名来请求网络资源会更有效？" class="headerlink" title="7. 为什么利用多个域名来请求网络资源会更有效？"></a>7. 为什么利用多个域名来请求网络资源会更有效？</h3></li></ul></li><li>动静分离需求，使用不同的服务器处理请求。处理动态内容的只处理动态内容，不处理别的，提高效率。CDN缓存更方便</li><li>突破浏览器并发限制：相关问题： 浏览器同一时间可以从一个域名下载多少资源？（即： 浏览器并发请求数）</li><li>也就是说：同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止。不同浏览器这个限制的数目不一样。</li><li>Cookieless, 节省带宽，尤其是上行带宽 一般比下行要慢。</li><li>用户的每次访问，都会带上自己的cookie ，挺大的。假如twitter 的图片放在主站域名下，那么用户每次访问图片时，request header 里就会带有自己的cookie ，header 里的cookie 还不能压缩，而图片是不需要知道用户的cookie 的，所以这部分带宽就白白浪费了。</li><li>节约主域名的连接数，从而提高客户端网络带宽的利用率，优化页面响应。因为老的浏览器（IE6是典型），针对同一个域名只允许同时保持两个HTTP连接。将图片等资源请求分配到其他域名上，避免了大图片之类的并不一定重要的内容阻塞住主域名上其他后续资源的连接（比如ajax请求）。</li><li>避免不必要的安全问题( 上传js窃取主站cookie之类的)<h3 id="8-进程和线程的区别"><a href="#8-进程和线程的区别" class="headerlink" title="8.进程和线程的区别"></a>8.进程和线程的区别</h3></li><li>一个程序至少有一个进程,一个进程至少有一个线程.</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>线程是独立调度的基本单位, 进程是拥有资源的基本单位</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>线程在执行过程中与进程还是有区别的。<ul><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。</li><li>但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li></ul></li><li>从逻辑角度来看，<ul><li>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。<h3 id="9-前端开发的优化问题"><a href="#9-前端开发的优化问题" class="headerlink" title="9. 前端开发的优化问题"></a>9. 前端开发的优化问题</h3></li></ul></li><li>前端开发的优化问题：<ul><li>(1) 减少http请求次数：css spirit,data uri</li><li>(2) JS，CSS源码压缩</li><li>(3) 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</li><li>(4) 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</li><li>(5) 用setTimeout来避免页面失去响应</li><li>(6) 用hash-table来优化查找</li><li>(7) 当需要设置的样式很多时设置className而不是直接操作style </li><li>(8) 少用全局变量</li><li>(9) 缓存DOM节点查找的结果</li><li>(10) 避免使用CSS Expression</li><li>(11) 图片预载</li><li>(12) 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢</li></ul></li><li>如何控制网页在网络传输过程中的数据量<ul><li>（1）启用GZIP压缩</li><li>（2）保持良好的编程习惯，避免重复的CSS，JavaScript代码，多余的HTML标签和属性</li></ul></li></ul><h3 id="10-Flash、Ajax各自的优缺点，在使用中如何取舍"><a href="#10-Flash、Ajax各自的优缺点，在使用中如何取舍" class="headerlink" title="10. Flash、Ajax各自的优缺点，在使用中如何取舍?"></a>10. Flash、Ajax各自的优缺点，在使用中如何取舍?</h3><ul><li>Ajax的优势<ul><li>(1) 可搜索型<br>　　+ (2) 开放性<br>　　+ (3) 费用<br>　　+ (4) 易用性<br>　　+ (5) 易于开发</li></ul></li><li>Flash的优势<ul><li>(1) 多媒体处理</li><li>(2) 兼容性</li><li>(3) 矢量图形 比SVG，Canvas优势大很多</li><li>(4) 客户端资源调度，比如麦克风，摄像头</li></ul></li></ul><h2 id="二、CSS"><a href="#二、CSS" class="headerlink" title="二、CSS"></a>二、CSS</h2><h3 id="1-CSS3"><a href="#1-CSS3" class="headerlink" title="1. CSS3"></a>1. CSS3</h3><p>　　CSS3新特性：</p><ul><li>新增各种CSS选择器   (: not(.input): 所有class不是“input”的节点）</li><li>圆角border-radiuis</li><li>多列布局：multi-column layout</li><li>阴影和反射： multi-column layout</li><li>文字特效：text-shadow</li><li>线性渐变： gradient</li><li>旋转：transform</li><li>缩放，定位，倾斜，动画，多背景：transform: \scale(0.85,0.90) \ translate(0px, -30px) \ skew(-9deg, 0deg) \ Animation</li></ul><h3 id="2-什么是无样式内容闪烁-如何避免"><a href="#2-什么是无样式内容闪烁-如何避免" class="headerlink" title="2. 什么是无样式内容闪烁?如何避免?"></a>2. 什么是无样式内容闪烁?如何避免?</h3><ul><li>what?<ul><li>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。</li></ul></li><li>why?<ul><li>使用import导入样式表</li><li>将样式表放在页面底部</li><li>有几个样式表,放在页面不同位置</li><li>原因即:当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</li></ul></li><li>how?<ul><li>使用LINK标签将样式表放在文档HEAD中。<h3 id="3-display-none-和-visibility-hidden的区别"><a href="#3-display-none-和-visibility-hidden的区别" class="headerlink" title="3. display:none 和 visibility: hidden的区别"></a>3. display:none 和 visibility: hidden的区别</h3></li></ul></li><li>display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li><li>visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。<h3 id="4-解释浮动和工作原理"><a href="#4-解释浮动和工作原理" class="headerlink" title="4. 解释浮动和工作原理"></a>4. 解释浮动和工作原理</h3></li><li>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。</li><li>假如某个div元素A是浮动的，如果A元素上一个元素也是浮动的，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素上一个元素是标准流中的元素，那么A的相对垂直位置不会改变，也就是说A的顶部总是和上一个元素的底部对齐。</li><li>清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。</li><li>关于清除浮动:清除浮动可以理解为打破横向排列。 clear: none | left | right | both</li><li>对于CSS的清除浮动(clear)，一定要牢记：这个规则只能影响使用清除的元素本身，不能影响其他元素。</li></ul><h3 id="5-清除浮动"><a href="#5-清除浮动" class="headerlink" title="5. 清除浮动"></a>5. 清除浮动</h3><ul><li>在浮动元素后面添加空标签 clear:both</li><li>给父标签使用overflow: hidden/auto;zoom:1</li><li>父级div定义, 使用伪类:after和zoom<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfloat</span><span class="selector-pseudo">:after</span>&#123;<span class="attribute">display</span>:block;<span class="attribute">clear</span>:both;<span class="attribute">content</span>:<span class="string">""</span>;<span class="attribute">visibility</span>:hidden;<span class="attribute">height</span>:<span class="number">0</span>&#125;</span><br><span class="line"><span class="selector-class">.clearfloat</span>&#123;<span class="attribute">zoom</span>:<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><p>　　zoom:1的作用： 触发IE下的hasLayout。zoom是IE浏览器专有属性，可以设置或检索对象的缩放比例。</p><p>　　当设置了zoom的值之后，所设置的元素就会扩大或缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。</p><h3 id="6-解释CSS-Sprites-以及你要如何使用"><a href="#6-解释CSS-Sprites-以及你要如何使用" class="headerlink" title="6. 解释CSS Sprites, 以及你要如何使用?"></a>6. 解释CSS Sprites, 以及你要如何使用?</h3><ul><li>CSS Sprites其实就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位，background-position可以用数字能精确的定位出背景图片的位置。</li></ul><h3 id="7-你最喜欢的图片替换方法是什么，你如何选择使用"><a href="#7-你最喜欢的图片替换方法是什么，你如何选择使用" class="headerlink" title="7. 你最喜欢的图片替换方法是什么，你如何选择使用?"></a>7. 你最喜欢的图片替换方法是什么，你如何选择使用?</h3><ol><li><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image.gif"</span> <span class="attr">alt</span>=<span class="string">"Image Replacement"</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>移开文字:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Image Replacement<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">h1&#123; background:url(hello_world.gif) no-repeat; width: 150px; height: 35px; &#125;</span><br><span class="line">span &#123; display: none; &#125;</span><br><span class="line"><span class="comment">&lt;!--注意问题:①结构性需要增加一个标签包裹文本　　②需要把背景图设置在外标签上,并把文本外标签隐藏.--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--缺点: 不利于阅览器浏览网页--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>text-indent属性，并且给其设置一个较大的负值，x达到隐藏文本的效果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"technique-three"</span>&gt;</span>w3cplus<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">.technique-three &#123;</span><br><span class="line">  width: 329px;</span><br><span class="line">  height: 79px;</span><br><span class="line">  background: url(images/w3cplus-logo.png);</span><br><span class="line">  text-indent: -9999px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们此处使用一个透明的gif图片，通过在img标签中的“alt”属性来弥补display:none。这样阅读器之类的就能阅读到所替换的文本是什么</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"technique-five"</span>&gt;</span></span><br><span class="line">  &lt;img src="images/blank.gif" alt="w3cplus" /&lt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>w3cplus<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.technique-five &#123;</span><br><span class="line">  width: 329px;</span><br><span class="line">  height: 79px;</span><br><span class="line">  background: url(images/w3cplus-logo.png);</span><br><span class="line">&#125;</span><br><span class="line">.technique-five span &#123;</span><br><span class="line">  display: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用零高度来隐藏文本，但为了显示背景图片，需要设置一个与替换图片一样的大小的padding值</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"technique-six"</span>&gt;</span>w3cplus<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">.technique-six &#123;</span><br><span class="line">  width: 329px;</span><br><span class="line">  padding: 79px 0 0 0;</span><br><span class="line">  height: 0px;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  background: url(images/w3cplus-logo.png);</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过把span的大小都设置为“0”，来达到隐藏文本效果，这样阅读器就能完全阅读到，而且又达到了图片替换文本的效果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"technique-seven"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>w3cplus<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">.technique-seven &#123;</span><br><span class="line">  width: 329px;</span><br><span class="line">  height: 79px;</span><br><span class="line">  background: url(images/w3cplus-logo.png);</span><br><span class="line">&#125;</span><br><span class="line">.technique-seven span &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  font-size: 0;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用一个空白的span标签来放置背景图片，并对其进行绝对定位，使用覆盖文本，达到隐藏替换文本的效果。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"technique-eight"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>w3cplus</span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">.technique-eight &#123;</span><br><span class="line">  width: 329px;</span><br><span class="line">  height: 79px;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.technique-eight span &#123;</span><br><span class="line">  background: url(images/w3cplus-logo.png);</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置字体为微小值，但这里需要注意一点不能忘了设置字体色和替换图片色一样，不然会有一个小点显示出来</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"technique-nine"</span>&gt;</span>w3cplus<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">.technique-nine &#123;</span><br><span class="line">  width: 329px;</span><br><span class="line">  height: 79px;</span><br><span class="line">  background: url(images/w3cplus-logo.png);</span><br><span class="line">  font-size: 1px;</span><br><span class="line">  color: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用css的clip属性来实现图片替换文本的效果</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"technique-ten"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>w3cplus<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">.technique-ten &#123;</span><br><span class="line">  width: 329px;</span><br><span class="line">  height: 79px;</span><br><span class="line">  background: url(images/w3cplus-logo.png);</span><br><span class="line">&#125;</span><br><span class="line">             </span><br><span class="line">.technique-ten span &#123;</span><br><span class="line">  border: 0 !important;</span><br><span class="line">  clip: rect(1px 1px 1px 1px);</span><br><span class="line">  clip: rect(1px,1px,1px,1px);</span><br><span class="line">  height: 1px !important;</span><br><span class="line">  margin: -1px;</span><br><span class="line">  overflow: hidden;</span><br><span class="line">  padding: 0 !important;</span><br><span class="line">  position: absolute !important;</span><br><span class="line">  width: 1px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="8-讨论CSS-hacks-条件引用或者其他"><a href="#8-讨论CSS-hacks-条件引用或者其他" class="headerlink" title="8. 讨论CSS hacks, 条件引用或者其他"></a>8. 讨论CSS hacks, 条件引用或者其他</h3><ul><li>hacks　<ul><li>_width针对于ie6。*width,+width针对于ie6,7。</li><li>color: red\9;/<em>IE8以及以下版本浏览器</em>/（但是测试可以兼容到ie10。</li><li>*+html与*html是IE特有的标签, firefox暂不支持.而<em>+html又为IE7特有标签（但是测试*html兼容ie6-10。</em>+兼容ie7-10）。</li><li>!important 在IE中会被忽视，ie6,7,8不识别，ie9+（包括ie9）是识别的。</li></ul></li><li>条件引用<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if !IE]&gt;&lt;!--&gt;</span> 除IE外都可识别 <span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-如何为有功能限制的浏览器提供网页"><a href="#9-如何为有功能限制的浏览器提供网页" class="headerlink" title="9. 如何为有功能限制的浏览器提供网页?"></a>9. 如何为有功能限制的浏览器提供网页?</h3><ul><li>功能限制的浏览器, 比如低版本IE, 手机浏览器, 等会在很多功能上不符合Web标准, 而应对方式主要有:<ul><li>只提供符合Web标准的页面</li><li>提供另一个符合那些浏览器标准的页面</li><li>兼容: 两种思路:<ul><li>渐进增强: 提供一个可用的原型，后来再为高级浏览器提供优化</li><li>优雅降级: 据高级浏览器提供一个版本，然后有功能限制的浏览器只需要一个刚好能用的版本</li></ul></li><li>相关技术:<ul><li>Media Query</li><li>CSS hack</li><li>条件判断<code>&lt;! --[if !IE]&gt;&lt;!--&gt;除IE外都可识别&lt;!--&lt;![endif]--&gt;</code></li></ul></li></ul></li></ul><h3 id="10-在书写高效-CSS-时会有哪些问题需要考虑"><a href="#10-在书写高效-CSS-时会有哪些问题需要考虑" class="headerlink" title="10. 在书写高效 CSS 时会有哪些问题需要考虑?"></a>10. 在书写高效 CSS 时会有哪些问题需要考虑?</h3><ol><li>reset。参照下题“描述下 “reset” CSS 文件的作用和使用它的好处”的答案。</li><li>规范命名。尤其对于没有语义化的html标签，例如div，所赋予的class值要特别注意。</li><li>抽取可重用的部件，注意层叠样式表的“优先级”。</li></ol><h3 id="11-如何优化网页的打印样式"><a href="#11-如何优化网页的打印样式" class="headerlink" title="11. 如何优化网页的打印样式?"></a>11. 如何优化网页的打印样式?</h3><ul><li>针对打印机的样式: @media print{…}</li></ul><h3 id="12-描述下你曾经使用过的-CSS-预处理的优缺点"><a href="#12-描述下你曾经使用过的-CSS-预处理的优缺点" class="headerlink" title="12. 描述下你曾经使用过的 CSS 预处理的优缺点"></a>12. 描述下你曾经使用过的 CSS 预处理的优缺点</h3><ul><li>优点: <ul><li>结构清晰, 便于扩展</li><li>可以方便屏幕浏览器私有语法差异</li><li>可以轻松实现多重继承</li><li>完全兼容css代码</li></ul></li></ul><h3 id="13-如果设计中使用了非标准的字体，你该如何去实现？"><a href="#13-如果设计中使用了非标准的字体，你该如何去实现？" class="headerlink" title="13. 如果设计中使用了非标准的字体，你该如何去实现？"></a>13. 如果设计中使用了非标准的字体，你该如何去实现？</h3><ul><li>图片替代</li><li>web : fonts在线字库</li><li>@font-face</li></ul><h3 id="14-解释下浏览器是如何判断元素是否匹配某个-CSS-选择器？"><a href="#14-解释下浏览器是如何判断元素是否匹配某个-CSS-选择器？" class="headerlink" title="14. 解释下浏览器是如何判断元素是否匹配某个 CSS 选择器？"></a>14. 解释下浏览器是如何判断元素是否匹配某个 CSS 选择器？</h3><p>从后往前判断。</p><p>浏览器先产生一个元素集合，这个集合往往由最后一个部分的索引产生（如果没有索引就是所有元素的集合）。然后向上匹配，如果不符合上一个部分，就把元素从集合中删除，直到真个选择器都匹配完，还在集合中的元素就匹配这个选择器了。</p><p>举个例子，有选择器：</p><p>body.ready #wrapper &gt; .lol233</p><p>先把所有 class 中有lol233的元素拿出来组成一个集合，然后上一层，对每一个集合中的元素，如果元素的 parent id 不为 #wrapper 则把元素从集合中删去。再向上，从这个元素的父元素开始向上找，没有找到一个 tagName 为 body 且 class 中有 ready 的元素，就把原来的元素从集合中删去。</p><p>至此这个选择器匹配结束，所有还在集合中的元素满足。</p><p>大体就是这样，不过浏览器还会有一些奇怪的优化。</p><p>为什么从后往前匹配因为效率和文档流的解析方向。效率不必说，找元素的父亲和之前的兄弟比遍历所哟儿子快而且方便。关于文档流的解析方向，是因为现在的 CSS，一个元素只要确定了这个元素在文档流之前出现过的所有元素，就能确定他的匹配情况。应用在即使 html 没有载入完成，浏览器也能根据已经载入的这一部分信息完全确定出现过的元素的属性。</p><p>　　为什么是用集合主要也还是效率。基于 CSS Rule 数量远远小于元素数量的假设和索引的运用，遍历每一条 CSS Rule 通过集合筛选，比遍历每一个元素再遍历每一条 Rule 匹配要快得多。　　</p><h3 id="15-解释一下你对盒模型的理解，以及如何在-CSS-中告诉浏览器使用不同的盒模型来渲染你的布局。"><a href="#15-解释一下你对盒模型的理解，以及如何在-CSS-中告诉浏览器使用不同的盒模型来渲染你的布局。" class="headerlink" title="15. 解释一下你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。"></a>15. 解释一下你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。</h3><p>盒模型：文档中的每个元素被描绘为矩形盒子，渲染引擎的目的就是判定大小，属性——比如它的颜色、背景、边框方面——及这些盒子的位置。</p><p>　　在CSS中，这些矩形盒子用标准盒模型来描述。这个模型描述了一个元素所占用的空间。每一个盒子有四条边界：外边距边界margin edge，边框边界border edge，内边距边界padding edge和内容边界content edge。</p><p>　　内容区域是真正包含元素内容的区域，位于内容边界的内部，它的大小为内容宽度或content-box宽及内容高度或content-box高。如果box-sizing为默认值，width、min-width、max-width、height、min-height和max-height控制内容大小。</p><p>　　内边距区域padding area用内容可能的边框之间的空白区域扩展内容区域。通常有背景——颜色或图片（不透明图片盖住背景颜色）。</p><p>　　边框区域扩展了内边距区域。它位于边框边界内部，大小为border-box宽和border-box高。</p><p>　　外边距区域margin area用空白区域扩展边框区域，以分开相邻的元素。它的大小为margin-box的高宽。</p><p>　　在外边距合并的情况下，由于盒之间共享外边距，外边距不容易弄清楚。</p><p>　　对于非替换的行内元素来说，尽管内容周围存在内边距与边框，但其占用空间（行高）由line-height属性决定。</p><p>　　盒子模型分为两类：W3C标准盒子模型和IE盒子模型 （微软确实不喜欢服从他家的标准）</p><p>　　这两者的关键差别就在于：</p><ul><li>W3C盒子模型——属性高（height）和属性宽（width）这两个值不包含 填充（padding）和边框（border）</li><li>IE盒子模型——属性高（height）和属性宽（width）这两个值包含 填充（padding）和边框（border）</li></ul><p>　　我们在编写页面代码的时候应该尽量使用标准的W3C盒子模型（需要在页面中声明DOCTYPE类型）。</p><p>　　各浏览器盒模型的组成结构是一致的，区别只是在”怪异模式”下宽度和高度的计算方式，而“标准模式”下则没有区别。组成结构以宽度为例：总宽度=marginLeft+borderLeft+paddingLeft+contentWidth+paddingRight+borderRight+marginRight（W3C标准盒子模型）。页面在“怪异模式”下，css中为元素的width和height设置的值在标准浏览器和ie系列(ie9除外)里的代表的含义是不同的（IE盒子模型）。 </p><p>   　因而解决兼容型为题最简洁和值得推荐的方式是：下述的第一条。 </p><p>将页面设为“标准模式”。添加对应的dtd标识<br>使用hack或者在外面套上一层wrapper </p><h3 id="16-描述下”reset”css文件的作用和使用它的好处"><a href="#16-描述下”reset”css文件的作用和使用它的好处" class="headerlink" title="16. 描述下”reset”css文件的作用和使用它的好处"></a>16. 描述下”reset”css文件的作用和使用它的好处</h3><p>　　reset.css能够重置浏览器的默认属性。不同的浏览器具有不同的样式，重置能够使其统一。比如说ie浏览器和FF浏览器下button显示不同，通过reset能够统一样式，显示相同的效果。但是很多reset是没必要的，多写了会增加浏览器在渲染页面的负担。</p><p>　　比如说，</p><p>　　　　1）我们不应该对行内元素设置无效的属性，对span设置width和height，margin都不会生效的。</p><p>　　　　2）对于absolute和fixed定位的固定尺寸（设置了width和height属性），如果设置了top和left属性，那么bottom和right，margin和float就没有作用。</p><p>　　　　3）后面设置的属性将会覆盖前面重复设置的属性。 </p><p>期待能够指出它的负面影响，或者提到它的一个更好的替换者”normalize”   normalize.css是一个可以定制的css文件，它让不同的浏览器在渲染元素时形式更统一。</p><h3 id="17-请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？"><a href="#17-请解释一下-box-sizing-border-box-的作用-并且说明使用它有什么好处？" class="headerlink" title="17. 请解释一下 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？"></a>17. 请解释一下 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？</h3><p>　　说到 IE 的 bug，在 IE6以前的版本中，IE对盒模型的解析出现一些问题，跟其它浏览器不同，将 border 与 padding 都包含在 width 之内。而另外一些浏览器则与它相反，是不包括border和padding的。对于IE浏览器，当我们设置 box-sizing: content-box; 时，浏览器对盒模型的解释遵从我们之前认识到的 W3C 标准，当它定义width和height时，它的宽度不包括border和padding；对于非IE浏览器，当我们设置box-sizing: border-box; 时，浏览器对盒模型的解释与 IE6之前的版本相同，当它定义width和height时，border和padding则是被包含在宽高之内的。内容的宽和高可以通过定义的“width”和 “height”减去相应方向的“padding”和“border”的宽度得到。内容的宽和高必须保证不能为负，必要时将自动增大该元素border box的尺寸以使其内容的宽或高最小为0。</p><p>　　使用 * { box-sizing: border-box; }能够统一IE和非IE浏览器之间的差异。</p><h3 id="18-block-inline和inline-block的区别"><a href="#18-block-inline和inline-block的区别" class="headerlink" title="18. block, inline和inline-block的区别"></a>18. block, inline和inline-block的区别</h3><ul><li>起新行<ul><li>block元素会独占一行, 多个block元素会各自新起一行. 默认情况下, block元素宽度自动填满其父元素宽度</li><li>inline元素不会独占一行, 多个相邻的行内元素会排列在同一行里, 直到一行排列不下, 才会新换一行, 其宽度随元素的内容而变化</li></ul></li><li>设置宽高</li></ul><ul><li>block元素可以设置width, height属性. 块级元素即使设置了宽度, 仍然独占一行</li><li>inline元素设置width, height无效</li></ul><ul><li>内外边距</li></ul><ul><li>block元素可以设置margin和padding属性</li><li>inline元素的margin和padding属性,水平方向的padding-left, padding-right, margin-left, margin-right都会产生边距效果. 但是数值方向的 margin/padding-top/bottom不会产生边距效果</li></ul><ul><li><p>包含</p><ul><li>block可以包含inline和block元素,而inline元只能包含inline元素</li></ul></li><li><p>而display: inline-block, 则是将对象呈现为inline对象, 但是对象的内容作为block对象呈现. 之后的内联对象会被排列到一行内. 比如我们可以给一个link(a元素)inline-block的属性, 使其既有block的高宽特性又有inline的同行特性</p><h3 id="19-css动画和js动画的优缺点"><a href="#19-css动画和js动画的优缺点" class="headerlink" title="19. css动画和js动画的优缺点"></a>19. css动画和js动画的优缺点</h3><p>　　<strong>CSS3的动画</strong></p></li><li><p>优点：</p><ol><li>在性能上会稍微好一些，浏览器会对CSS3的动画做一些优化（比如专门新建一个图层用来跑动画）</li><li>代码相对简单</li></ol></li><li><p>缺点：</p><ol><li>在动画控制上不够灵活</li><li>兼容性不好</li><li>部分动画功能无法实现（如滚动动画，视差滚动等）</li></ol></li></ul><p>　　<strong>JavaScript的动画</strong></p><ul><li>优点：<ol><li>控制能力很强，可以单帧的控制、变换</li><li>兼容性好，写得好完全可以兼容IE6，且功能强大。</li></ol></li><li>缺点：<ul><li>计算没有css快，另外经常需要依赖其他的库。</li></ul></li></ul><p>　<strong>结论</strong></p><ul><li><p>所以，不复杂的动画完全可以用css实现，复杂一些的，或者需要交互的时候，用js会靠谱一些~</p><h3 id="20-你用过媒体查询，或针对移动端的布局-CSS-吗？"><a href="#20-你用过媒体查询，或针对移动端的布局-CSS-吗？" class="headerlink" title="20. 你用过媒体查询，或针对移动端的布局/CSS 吗？"></a>20. 你用过媒体查询，或针对移动端的布局/CSS 吗？</h3><p>　　通过媒体查询可以为不同大小和尺寸的媒体定义不同的css，适合相应的设备显示；即响应式布局</p></li><li><p>@media screen and (min-width: 400px) and (max-width: 700px) { … }</p></li><li><p>@media handheld and (min-width: 20em), screen and (min-width: 20em) { … }</p></li></ul><h3 id="21-有哪些隐藏内容的方法-同时还要保证屏幕阅读器可用"><a href="#21-有哪些隐藏内容的方法-同时还要保证屏幕阅读器可用" class="headerlink" title="21. 有哪些隐藏内容的方法(同时还要保证屏幕阅读器可用)"></a>21. 有哪些隐藏内容的方法(同时还要保证屏幕阅读器可用)</h3><p>display:none或者visibility:hidden，overflow:hidden。</p><ol><li>display: none;的缺陷<ul><li>搜索引擎可能认为被隐藏的文字属于垃圾信息而被忽略</li><li>屏幕阅读器（是为视觉上有障碍的人设计的读取屏幕内容的程序）会忽略被隐藏的文字。</li></ul></li><li>visibility: hidden;的缺陷<ul><li>隐藏的内容会占据他所应该占据物理空间</li></ul></li><li>overflow:hidden;一个比较合理的方法<ul><li>例：.texthidden { display:block; overflow: hidden; width: 0; height: 0; }</li></ul></li></ol><p>将宽度和高度设定为0，然后超过部分隐藏，就会弥补上述一、二方法中的缺陷，也达到了隐藏内容的目的</p><h3 id="22-CSS选择器级别"><a href="#22-CSS选择器级别" class="headerlink" title="22. CSS选择器级别"></a>22. CSS选择器级别</h3><ol><li>如果样式是行内样式（通过Style=””定义），那么a=1</li><li>b为ID选择器的总数</li><li>c为Class类选择器的数量。</li><li>d为类型选择器的数量</li><li>属性选择器，伪类选择器和class类选择器优先级一样，伪元素选择器和类型选择器一样</li><li>!important 权重最高，比 inline style 还要高。</li></ol><p>　　一般来讲，越详细的级别越高。CSS优先级包含四个级别（文内选择符，ID选择符，Class选择符，元素选择符）以及各级别出现的次数。根据这四个级别出现的次数计算得到CSS的优先级</p><h3 id="23-img设置属性title和alt的区别"><a href="#23-img设置属性title和alt的区别" class="headerlink" title="23. img设置属性title和alt的区别?"></a>23. img设置属性title和alt的区别?</h3><ul><li>Alt是img的特有属性, 或与<code>&lt;input type=&quot;image&quot;&gt;</code>配合使用，规定图像的替代文本. 如果无法显示图像, 浏览器将显示替代文本. 用于图片无法加载显示、读屏器阅读图片，可提高图片可 访问性，搜索引擎会重点分析。最长可包含1024个字符,</li><li>Title为元素提供附加的提示信息，用于鼠标滑到元素上的时候显示。其值可以比alt属性值设置的更长, 但是有些浏览器会截断过长的文字.</li></ul><h3 id="24-知道BFC吗"><a href="#24-知道BFC吗" class="headerlink" title="24. 知道BFC吗?"></a>24. 知道BFC吗?</h3><p>BFC指的是Block Formatting Context, 它提供了一个环境, html元素在这个环境中按照一定规则进行布局. 一个环境中的元素不会影响到其他环境中的布局. 决定了元素如何对其内容进行定位, 以及和其他元素的关系和相互作用.</p><p>　　其中: FC(Formatting Context): 指的是页面中的一个渲染区域, 并且拥有一套渲染规则, 它决定了其子元素如何定位, 以及与其他元素的相互关系和作用.</p><p>　　BFC: 块级格式化上下文, 指的是一个独立的块级渲染区域, 只有block-level box参与, 该区域拥有一套渲染规则来约束块级盒子的布局, 且与区域外部无关.</p><ul><li>BFC的生成:<ul><li>根元素</li><li>float的值不为none</li><li>overflow的值不为visible</li><li>display的值为 inline-block, table-cell, table-caption</li><li>position的值为absolute或fixed</li></ul></li><li>BFC的约束规则<ul><li>生成BFC元素的子元素会一个接一个的放置。垂直方向上他们的起点是一个包含块的顶部，两个相邻子元素之间的垂直距离取决于元素的margin特性。在BFC中相邻的块级元素外边距会折叠。</li><li>生成BFC元素的子元素中，每一个子元素做外边距与包含块的左边界相接触，（对于从右到左的格式化，右外边距接触右边界），即使浮动元素也是如此（尽管子元素的内容区域会由于浮动而压缩），除非这个子元素也创建了一个新的BFC（如它自身也是一个浮动元素）。</li><li>分解:<ul><li>内部的Box会在垂直方向上一个接一个的放置</li><li>垂直方向上的距离由margin决定。（完整的说法是：属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关。）</li><li>每个元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此。（这说明BFC中子元素不会超出他的包含块，而position为absolute的元素可以超出他的包含块边界）</li><li>BFC的区域不会与float的元素区域重叠</li><li>计算BFC的高度时，浮动子元素也参与计算</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li></ul></li></ul></li><li>BFC在布局中的应用<ul><li>不和浮动元素重叠:<ul><li>如果一个浮动元素后面跟着一个非浮动元素, 就会产生覆盖</li></ul></li><li>防止margin重叠:<ul><li>同一个BFC中的两个相邻Box才会发生重叠与方向无关，不过由于上文提到的第一条限制，我们甚少看到水平方向的margin重叠。这在IE中是个例外，IE可以设置write-mode</li></ul></li><li>解决浮动相关问题<ul><li>父元素: overflow:hidden    IE: zoom:1(hasLayout)</li><li>根本原因在于创建BFC的元素，子浮动元素也会参与其高度计算，即不会产生高度塌陷问题。实际上只要让父元素生成BFC即可，并不只有这两种方式。</li></ul></li><li>多栏布局<ul><li>比如左右两栏宽度固定, 中间栏自适应 则中间栏设置 overflow:hidden生成BFC</li></ul></li></ul></li><li>IE中类似概念: hasLayout</li></ul><h3 id="25-行内元素有哪些？块级元素有哪些？空元素有哪些？"><a href="#25-行内元素有哪些？块级元素有哪些？空元素有哪些？" class="headerlink" title="25. 行内元素有哪些？块级元素有哪些？空元素有哪些？"></a>25. 行内元素有哪些？块级元素有哪些？空元素有哪些？</h3><ul><li>行内元素有：span img input select strong</li><li>块级元素有：div ul ol dl dt dd h1 h2 h3 h4 p…</li><li>常见的空元素：br hr img input link meta  base area command embed keygen param source track wbr….<h2 id="三、html"><a href="#三、html" class="headerlink" title="三、html"></a>三、html</h2><h3 id="1-h5的改进"><a href="#1-h5的改进" class="headerlink" title="1. h5的改进:"></a>1. h5的改进:</h3></li><li>新元素<ul><li>画布canvas: HTML5 <canvas> 元素用于图形的绘制，通过脚本 (通常是JavaScript)来完成</canvas></li><li>音频audio</li><li>视频video</li><li>语义性: article,  nav ,  footer, section, aside, hgroup等.</li><li>时间time</li></ul></li><li>新属性<ul><li>拖放: draggable   <code>&lt;img draggable=&quot;true&quot;&gt;</code></li><li>可编辑: contenteditable</li></ul></li><li>新事件<ul><li>拖放 ondrag ondrop</li><li>关闭页面 onunload</li><li>窗口大小改变 onresize</li></ul></li><li>取消了一些元素: font center等</li><li>新的DOCTYPE声明  <!DOCTYPE html> </li><li>完全支持CSS3</li><li>Video和Audio</li><li>2D/3D制图</li><li>本地存储</li><li>本地SQL数据</li><li>Web应用</li></ul><h3 id="2-什么是语义化的html"><a href="#2-什么是语义化的html" class="headerlink" title="2. 什么是语义化的html?"></a>2. 什么是语义化的html?</h3><ul><li>what?<ul><li>根据内容的结构（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。</li></ul></li><li>why?<ul><li>为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；</li><li>用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；</li><li>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重</li><li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li><li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li></ul></li><li>how?<ul><li>尽可能少的使用无语义的标签div和span；</li><li>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li><li>不要使用纯样式标签，如：b、font、u等，改用css设置。</li><li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li><li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li><li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；</li><li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li></ul></li></ul><h3 id="3-从前端角度出发谈谈做好seo需要考虑什么"><a href="#3-从前端角度出发谈谈做好seo需要考虑什么" class="headerlink" title="3. 从前端角度出发谈谈做好seo需要考虑什么?"></a>3. 从前端角度出发谈谈做好seo需要考虑什么?</h3><ul><li>语义化html标签</li><li>合理的title, description, keywords;</li><li>重要的html代码放前面</li><li>少用iframe, 搜索引擎不会抓取iframe中的内容</li><li>图片加上alt<h3 id="4-文档类型-DOCTYPE"><a href="#4-文档类型-DOCTYPE" class="headerlink" title="4. 文档类型(DOCTYPE)"></a>4. 文档类型(DOCTYPE)</h3></li><li>作用: doctype声明位于文档中最前面的位置，处于标签之前，告知浏览器使用的是哪种规范。</li><li>类型: 三种: Strict、Transitional 以及 Frameset </li><li>如果不声明: 不写doctype，浏览器会进入quirks mode （混杂模式）。即，如果不声明doctype，浏览器不引入w3c的标准，那么早期的浏览器会按照自己的解析方式渲染页面。浏览器采用自身方式解析页面的行为称为”quirks mode（混杂模式也称怪异模式）”；采用w3c方式解析就是”strict mode（标准模式）”。 如果完全采用strictmode就不会出任何的差错，但这样会降低程序的容错率，加重开发人员的难度</li><li>用哪种: <ul><li>没有doctype声明的采用quirks mode解析</li><li>对于有doctype的大多数采用standard mord。</li><li>特殊情况：<ul><li>对于那些浏览器不能识别的doctype ,浏览器采用quirks mode；</li><li>没有声明DTD或者html版本声明低于4.0采用quirks mode，其他使用standard mode；</li><li>ie6中，如果在doctype声明前有一个xml声明(比如:<?xml version="1.0" encoding="iso-8859-1"?>)，则采用quirks mode解析</li></ul></li></ul></li><li>标准模式与怪异模式的区别:<ul><li>标准模式：浏览器根据规范呈现页面</li><li>混杂模式（怪异模式）：页面以一种比较宽松的兼容方式显示。</li><li>他们最大的不同是对盒模型的解析。<ul><li>在strict mode中 ：width是内容宽度 ，也就是说,元素真正的宽度 = margin-left + border-left-width + padding-left + width + padding-right + border-right- width +  margin-right;</li><li>在quirks mode中 ：width则是元素的实际宽度 ，内容宽度 = width - (margin-left + margin-right + padding-left + padding-right + border-left-width + 　border-right-width)<h3 id="5-使用XHTML的局限有哪些"><a href="#5-使用XHTML的局限有哪些" class="headerlink" title="5. 使用XHTML的局限有哪些?"></a>5. 使用XHTML的局限有哪些?</h3></li></ul></li></ul></li><li>XHTML较为严格，标签必须闭合，必须要body，head等</li><li>如果页面使用 ‘application/xhtml+xml’ 一些老的浏览器并不兼容<h3 id="6-如果网页内容需要多语言-要怎么做"><a href="#6-如果网页内容需要多语言-要怎么做" class="headerlink" title="6. 如果网页内容需要多语言,要怎么做?"></a>6. 如果网页内容需要多语言,要怎么做?</h3>采用统一编码utf-8模式<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;META <span class="attribute">HTTP-EQUIV</span>=“Content-Type” <span class="attribute">CONTENT</span>=“text/html; <span class="attribute">CHARSET</span>=字符集"&gt;</span><br><span class="line">不写，根据浏览器默认字符集显示</span><br><span class="line"><span class="attribute">charset</span>=gb2312 简体中文</span><br><span class="line"><span class="attribute">charset</span>=big5 繁体中文</span><br><span class="line"><span class="attribute">charset</span>=EUC_KR 韩语</span><br><span class="line"><span class="attribute">charset</span>=Shift_JIS 或 EUC_JP 日语</span><br><span class="line">charset= KOI8-R / Windows-1251 俄语</span><br><span class="line"><span class="attribute">charset</span>=iso-8859-1 西欧语系（荷兰语,英语,法语,德语,意大利语,挪威语,葡萄牙语,瑞士语.等十八种语言）</span><br><span class="line"><span class="attribute">charset</span>=iso-8859-2 中欧语系</span><br><span class="line"><span class="attribute">charset</span>=iso-8859-5 斯拉夫语系（保加利亚语,Byelorussian语,马其顿语,俄语,塞尔维亚语,乌克兰语等）</span><br><span class="line"><span class="attribute">charset</span>=uft-8 unicode多语言</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-data-属性的作用"><a href="#7-data-属性的作用" class="headerlink" title="7. data-*属性的作用"></a>7. data-*属性的作用</h3><ul><li><p>html5规范里增加了一个自定义data属性</p></li><li><p>为前端开发者提供自定义的属性，这些属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> data-author=<span class="string">"david"</span> data-<span class="built_in">time</span>=<span class="string">"2011-06-20"</span> data-comment-<span class="built_in">num</span>=<span class="string">"10"</span>&gt;...&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line"><span class="keyword">div</span>.dataset.commentNum;<span class="comment"> // 可通过js获取 10</span></span><br></pre></td></tr></table></figure></li><li><p>data-为前端开发者提供自定义的属性，这些属性集可以通过对象的dataset属性获取，不支持该属性的浏览器可以通过 getAttribute方法获取。ppk提到过使用rel属性，lightbox库推广了rel属性，HTML5提供了data-做替代，这样可以更好 地使用自定义的属性</p></li><li><p>需要注意的是，data-之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。</p><h3 id="8-如果把-HTML5-看作做一个开放平台，那它的构建模块有哪些？"><a href="#8-如果把-HTML5-看作做一个开放平台，那它的构建模块有哪些？" class="headerlink" title="8. 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？"></a>8. 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？</h3></li></ul><ol><li>Web Storage API</li><li>基于位置服务LBS</li><li>无插件播放音频视频</li><li>调用相机和GPU图像处理单元等硬件设备</li><li>拖拽和Form API</li></ol><h3 id="9-请描述一下-cookies，sessionStorage-和-localStorage-的区别？"><a href="#9-请描述一下-cookies，sessionStorage-和-localStorage-的区别？" class="headerlink" title="9. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？"></a>9. 请描述一下 cookies，sessionStorage 和 localStorage 的区别？</h3><ul><li>cookie:<ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li></ul></li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>存储大小：<ul><li>cookie数据大小不能超过4k。</li><li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li></ul></li><li>有期时间：<ul><li>localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li><li>sessionStorage  数据在当前浏览器窗口关闭后自动删除。</li><li>cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li><li>作用域不同:<ul><li>sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；</li><li>localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li></ul></li><li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。</li><li>Web Storage 的 api 接口使用更方便。</li></ul><h3 id="10-浏览器本地存储与服务器端存储之间的区别"><a href="#10-浏览器本地存储与服务器端存储之间的区别" class="headerlink" title="10. 浏览器本地存储与服务器端存储之间的区别"></a>10. 浏览器本地存储与服务器端存储之间的区别</h3><ul><li>其实数据既可以在浏览器本地存储，也可以在服务器端存储。</li><li>浏览器端可以保存一些数据，需要的时候直接从本地获取，sessionStorage、localStorage和cookie都由浏览器存储在本地的数据。</li><li>服务器端也可以保存所有用户的所有数据，但需要的时候浏览器要向服务器请求数据。<ol><li>服务器端可以保存用户的持久数据，如数据库和云存储将用户的大量数据保存在服务器端。</li><li>服务器端也可以保存用户的临时会话数据。服务器端的session机制，如jsp的 session 对象，数据保存在服务器上。实现上，服务器和浏览器之间仅需传递session id即可，服务器根据session id找到对应用户的session对象。会话数据仅在一段时间内有效，这个时间就是server端设置的session有效期。</li></ol></li><li>服务器端保存所有的用户的数据，所以服务器端的开销较大，而浏览器端保存则把不同用户需要的数据分布保存在用户各自的浏览器中。</li><li>浏览器端一般只用来存储小数据，而服务器可以存储大数据或小数据。</li><li>服务器存储数据安全一些，浏览器只适合存储一般数据。<h3 id="11-sessionStorage和页面js数据对象的区别"><a href="#11-sessionStorage和页面js数据对象的区别" class="headerlink" title="11. sessionStorage和页面js数据对象的区别"></a>11. sessionStorage和页面js数据对象的区别</h3></li><li>页面中一般的 js 对象或数据的生存期是仅在当前页面有效，因此刷新页面或转到另一页面这样的重新加载页面的情况，数据就不存在了。</li><li>而sessionStorage 只要同源的同窗口（或tab）中，刷新页面或进入同源的不同页面，数据始终存在。也就是说只要这个浏览器窗口没有关闭，加载新页面或重新加载，数据仍然存在。<h3 id="12-canvas和svg的区别"><a href="#12-canvas和svg的区别" class="headerlink" title="12. canvas和svg的区别?"></a>12. canvas和svg的区别?</h3></li><li>svg: <ul><li>SVG是一种使用XML描述2D图形的语言</li><li>SVG基于XML, 这意味着SVG DOM中的每个元素都是可用的. 所以可以为每个元素附加JavaScript事件处理器</li><li>在SVG中, 每个被绘制的图像均被视为对象. 如果SVG对象的属性发生变化, 那么浏览器能够自动重现图像</li></ul></li><li>Canvas<ul><li>Canvas通过js来绘制2D图形</li><li>Canvas是逐像素进行渲染的</li><li>在Canvas中, 一旦图形被绘制完成, 它就不会继续得到浏览器的关注. 如果其位置发生变化, 那么整个场景也需要重新绘制, 包括任何或许已被图形覆盖的对象.</li></ul></li><li>区别<ul><li>Canvas支持分辨率, SVG不支持</li><li>Canvas不支持事件处理器, SVG支持</li><li>Canvas只有弱的文本渲染能力, 而SVG最适合带有大型渲染区域的应用程序(比如谷歌地图)</li><li>Canvas能够以.png或.jpg格式保存结果图像</li><li>SVG的复杂度过高的话会减慢渲染速度(任何过度使用DOM的应用都不快)</li><li>Canvas最适合图像密集型的游戏, 其中的许多对象会被频繁重绘. 而SVG不适合游戏应用</li><li>Canvas是基于位图的图像,它不能够改变大小, 只能缩放显示; SVG是基于矢量的, 所以它能够很好地处理图形大小的改变　　　　</li><li>Canvas提供的功能更原始, 适合像素处理, 动态渲染和大数据量绘制; SVG功能更完善, 适合静态图片显示, 高保真文档查看和打印的应用场景</li><li>绘制Canvas对象后, 不能使用脚本和CSS对它进行修改; 而SVG对象是文档对象模型的一部分, 所以可以随时使用脚本和CSS修改它们<h3 id="13-src和href的区别"><a href="#13-src和href的区别" class="headerlink" title="13. src和href的区别?"></a>13. src和href的区别?</h3></li></ul></li><li>src指向外部资源的位置, 用于替换当前元素, 比如js脚本, 图片等元素</li><li>href指向网络资源所在的位置, 用于在当前文档和引用资源间确定联系, 加载css<h2 id="四、js"><a href="#四、js" class="headerlink" title="四、js"></a>四、js</h2><h3 id="1-ajax-跨域-jsonp"><a href="#1-ajax-跨域-jsonp" class="headerlink" title="1. ajax, 跨域, jsonp"></a>1. ajax, 跨域, jsonp</h3>　　参考： <a href="http://www.cnblogs.com/haoyijing/p/5778155.html" target="_blank" rel="noopener">《JavaScript》高级程序设计第21章：Ajax和Comet</a></li></ul><p>　　　　　<a href="http://www.cnblogs.com/haoyijing/p/5760423.html#z6" target="_blank" rel="noopener">js跨域</a></p><p>　　　　　<a href="https://blog.csdn.net/u013194113/article/details/52034106#t1" target="_blank" rel="noopener">jQuery中Ajax操作</a></p><h3 id="2-apply和call的用法和区别"><a href="#2-apply和call的用法和区别" class="headerlink" title="2. apply和call的用法和区别:"></a>2. apply和call的用法和区别:</h3><ul><li>用法: 都能继承另一个对象的方法和属性,区别在于参数列表不一样</li><li>区别:<ul><li>Function.apply(obj, args) args是一个数组,作为参数传给Function</li><li>Function.call(obj, arg1, arg2,…)  arg*是参数列表</li><li>apply一个妙用: 可以将一个数组默认的转化为一个参数列表<ul><li>举个栗子: 有一个数组arr要push进一个新的数组中去, 如果用call的话需要把数组中的元素一个个取出来再push, 而用apply只有Array.prototype.push.apply(this, arr)</li></ul></li></ul></li></ul><h3 id="3-bind函数的兼容性"><a href="#3-bind函数的兼容性" class="headerlink" title="3. bind函数的兼容性"></a>3. bind函数的兼容性</h3><ul><li>用法:<ul><li>bind()函数会创建一个新函数, 为绑定函数。当调用这个绑定函数时,绑定函数会以创建它时传入bind方法的第一个参数作为this,传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数.</li><li>一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。　　<h3 id="4-解释下事件代理"><a href="#4-解释下事件代理" class="headerlink" title="4. 解释下事件代理"></a>4. 解释下事件代理</h3>事件委托利用了事件冒泡, 只指定一个事件处理程序, 就可以管理某一类型的所有事件.</li></ul></li></ul><p>例: </p><p>html部分: 要点击li弹出其id</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-1"</span>&gt;</span>Li 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-2"</span>&gt;</span>Li 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-3"</span>&gt;</span>Li 4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-4"</span>&gt;</span>Li 5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-5"</span>&gt;</span>Li 6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"li-6"</span>&gt;</span>Li 7<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js部分</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"list"</span>).addHandler(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toUpperCase == <span class="string">"LI"</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"List item"</span>, e,target.id, <span class="string">"was clicked!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="5-解释下js中this是怎么工作的"><a href="#5-解释下js中this是怎么工作的" class="headerlink" title="5. 解释下js中this是怎么工作的?"></a>5. 解释下js中this是怎么工作的?</h3><p>　　this 在 JavaScript 中主要由以下五种使用场景。</p><ul><li>作为函数调用，this 绑定全局对象，浏览器环境全局对象为 window 。</li><li>内部函数内部函数的 this 也绑定全局对象，应该绑定到其外层函数对应的对象上，这是 JavaScript的缺陷，用that替换。</li><li>作为构造函数使用，this 绑定到新创建的对象。</li><li>作为对象方法使用，this 绑定到该对象。</li><li>使用apply或call调用 this 将会被显式设置为函数调用的第一个参数。<h3 id="6-继承"><a href="#6-继承" class="headerlink" title="6. 继承"></a>6. 继承</h3>　　参考：<a href="http://www.cnblogs.com/haoyijing/p/5760586.htm" target="_blank" rel="noopener">js怎么实现继承？</a></li></ul><h3 id="7-AMD-vs-CommonJS？"><a href="#7-AMD-vs-CommonJS？" class="headerlink" title="7. AMD vs. CommonJS？"></a>7. AMD vs. CommonJS？</h3><p>答: AMD是依赖提前加载,CMD是依赖延时加载</p><h3 id="8-什么是哈希表"><a href="#8-什么是哈希表" class="headerlink" title="8. 什么是哈希表?"></a>8. 什么是哈希表?</h3><p>答:  哈希表（Hash table，也叫散列表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>　　使用哈希查找有两个步骤:</p><ol><li>使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突</li><li>处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，比如拉链法和线性探测法。</li></ol><p>元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，下面列出三种比较常用的：</p><ol><li><p>除法散列法<br>最直观的一种，上图使用的就是这种散列法，公式：<br>   index = value % 16<br>学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫“除法散列法”。</p></li><li><p>平方散列法<br>求index是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：<br>   index = (value * value) &gt;&gt; 28   （右移，除以2^28。记法：左移变大，是乘。右移变小，是除。）<br>如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的index都是0——非常失败。也许你还有个问题，value如果很大，value * value不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取index。</p></li><li><p>斐波那契（Fibonacci）散列法</p></li></ol><p>解决冲突的方法:</p><p>1.拉链法</p><p>　　将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法.</p><p>　　对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到等一应的链表，然后沿着链表顺序找到相应的键。</p><ol start="2"><li>线性探测法: </li></ol><p>　　使用数组中的空位解决碰撞冲突</p><h3 id="9-什么是闭包-闭包有什么作用"><a href="#9-什么是闭包-闭包有什么作用" class="headerlink" title="9. 什么是闭包? 闭包有什么作用?"></a>9. 什么是闭包? 闭包有什么作用?</h3><ul><li>闭包是指有权访问另一个函数作用域中的变量的函数. 创建闭包常见方式,就是在一个函数内部创建另一个函数.</li><li>作用: <ul><li>匿名自执行函数  (function (){ … })();   创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。</li><li>缓存, 可保留函数内部的值</li><li>实现封装</li><li>实现模板</li></ul></li></ul><h3 id="10-伪数组"><a href="#10-伪数组" class="headerlink" title="10. 伪数组:"></a>10. 伪数组:</h3><ul><li>什么是伪数组: <ul><li>伪数组是能通过Array.prototype.slice 转换为真正的数组的带有length属性的对象</li><li>比如arguments对象,还有像调用getElementsByTagName,document.childNodes之类的，它们都返回NodeList对象都属于伪数组</li><li>我们可以通过Array.prototype.slice.call(fakeArray)将伪数组转变为真正的Array对象: 返回新数组而不会修改原数组</li></ul></li></ul><h3 id="11-undefined和null的区别-还有undeclared"><a href="#11-undefined和null的区别-还有undeclared" class="headerlink" title="11. undefined和null的区别, 还有undeclared:"></a>11. undefined和null的区别, 还有undeclared:</h3><ul><li><p>null表示没有对象, 即此处不该有此值. 典型用法:</p><ol><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点。</li><li>null可以作为空指针. 只要意在保存对象的值还没有真正保存对象,就应该明确地让该对象保存null值.</li></ol></li><li><p>undefined表示缺少值, 即此处应该有值, 但还未定义.</p><ol><li>变量被声明了，但没有赋值时，就等于undefined。</li><li>调用函数时，应该提供的参数没有提供，该参数等于undefined。</li><li>对象没有赋值的属性，该属性的值为undefined。</li><li>函数没有返回值时，默认返回undefined。</li></ol></li><li><p>undeclared即为被污染的命名, 访问没有被声明的变量, 则会抛出异常, 终止执行. 即undeclared是一种语法错误</p></li></ul><h3 id="12-事件冒泡机制"><a href="#12-事件冒泡机制" class="headerlink" title="12. 事件冒泡机制:　　"></a>12. 事件冒泡机制:　　</h3><p>从目标元素开始，往顶层元素传播。途中如果有节点绑定了相应的事件处理函数，这些函数都会被一次触发。如果想阻止事件起泡，可以使用e.stopPropagation()（Firefox）或者e.cancelBubble=true（IE）来组织事件的冒泡传播。</p><h3 id="13-解释下为什么接下来这段代码不是-IIFE-立即调用的函数表达式-：function-foo"><a href="#13-解释下为什么接下来这段代码不是-IIFE-立即调用的函数表达式-：function-foo" class="headerlink" title="13. 解释下为什么接下来这段代码不是 IIFE(立即调用的函数表达式)：function foo(){ }();?"></a>13. 解释下为什么接下来这段代码不是 IIFE(立即调用的函数表达式)：function foo(){ }();?</h3><p>　　而函数定义（语句以function关键字开始）是不能被立即执行的，这无疑会导致语法的错误（SyntaxError）。当函数定义代码段包裹在括号内，使解析器可以将之识别为函数表达式，然后调用。IIFE:  (function foo(){})()　</p><p>　　区分  (function(){})(); 和  (function(){}());  其实两者实现效果一样。<br>　　函数字面量：首先声明一个函数对象，然后执行它。(function () { alert(1); })();</p><p>　　优先表达式：由于Javascript执行表达式是从圆括号里面到外面，所以可以用圆括号强制执行声明的函数。(function () { alert(2); }());</p><h3 id="14-“attribute”-和-“property”-的区别是什么？"><a href="#14-“attribute”-和-“property”-的区别是什么？" class="headerlink" title="14. “attribute” 和 “property” 的区别是什么？"></a>14. “attribute” 和 “property” 的区别是什么？</h3><p>　　DOM元素的attribute和property两者是不同的东西。attribute翻译为“特性”，property翻译为“属性”。</p><p>　　attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，attributes是一个类数组的容器，说得准确点就是NameNodeMap，不继承于Array.prototype，不能直接调用Array的方法。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。<div class="box" id="box" gameid="880">hello</div></p><p>　　property就是一个属性，如果把DOM元素看成是一个普通的Object对象，那么property就是一个以名值对(name=”value”)的形式存放在Object中的属性。要添加和删除property和普通的对象类似。</p><p>　　很多attribute节点还有一个相对应的property属性，比如上面的div元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。</p><p>　　总之，attribute节点都是在HTML代码中可见的，而property只是一个普通的名值对属性。</p><h3 id="15-请指出-document-load-和-document-ready-两个事件的区别。"><a href="#15-请指出-document-load-和-document-ready-两个事件的区别。" class="headerlink" title="15. 请指出 document load 和 document ready 两个事件的区别。"></a>15. 请指出 document load 和 document ready 两个事件的区别。</h3><ul><li>document.ready和onload的区别——JavaScript文档加载完成事件。页面加载完成有两种事件:<ul><li>一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）</li><li>二是onload，指示页面包含图片等文件在内的所有元素都加载完成。</li></ul></li><li>jQuery中$(function(){/* do something*/});他的作用或者意义就是:在DOM加载完成后就可以可以对DOM进行操作。一般情况先一个页面响应加载的顺序是，域名解析-加载html-加载js和css-加载图片等其他信息。<h3 id="16-什么是use-strict-其好处坏处分别是什么"><a href="#16-什么是use-strict-其好处坏处分别是什么" class="headerlink" title="16. 什么是use strict? 其好处坏处分别是什么?"></a>16. 什么是use strict? 其好处坏处分别是什么?</h3></li></ul><p>　　在所有的函数 (或者所有最外层函数) 的开始处加入 “use strict”; 指令启动严格模式。</p><p>“严格模式”有两种调用方法</p><ol><li><p>将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。</p></li><li><p>将整个脚本文件放在一个立即执行的匿名函数之中。</p></li></ol><ul><li><p>好处</p><ul><li>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</li><li>消除代码运行的一些不安全之处，保证代码运行的安全；</li><li>提高编译器效率，增加运行速度；</li><li>为未来新版本的Javascript做好铺垫。</li></ul></li><li><p>坏处　</p><ul><li>同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行　</li></ul></li></ul><h3 id="17-浏览器端的js包括哪几个部分"><a href="#17-浏览器端的js包括哪几个部分" class="headerlink" title="17. 浏览器端的js包括哪几个部分?"></a>17. 浏览器端的js包括哪几个部分?</h3><ul><li>核心( ECMAScript) , 文档对象模型(DOM), 浏览器对象模型(BOM)</li></ul><h3 id="18-DOM包括哪些对象"><a href="#18-DOM包括哪些对象" class="headerlink" title="18. DOM包括哪些对象?"></a>18. DOM包括哪些对象?</h3><ul><li><p>DOM是针对HTML和XML文档的一个API(应用程序编程接口). DOM描绘了一个层次化的节点树, 允许开发人员添加, 移除和修改页面的某一部分.</p></li><li><p>常用的DOM方法:</p><ul><li>getElementById(id)</li><li>getElementsByTagName()</li><li>appendChild(node)</li><li>removeChild(node)</li><li>replaceChild()</li><li>insertChild()</li><li>createElement()</li><li>createTextNode()</li><li>getAttribute()</li><li>setAttribute()</li></ul></li><li><p>常用的DOM属性</p><ul><li>innerHTML  节点(元素)的文本值</li><li>parentNode  节点(元素)的父节点</li><li>childNodes </li><li>attributes   节点(元素)的属性节点</li></ul></li></ul><h3 id="19-js有哪些基本类型"><a href="#19-js有哪些基本类型" class="headerlink" title="19. js有哪些基本类型?"></a>19. js有哪些基本类型?</h3><ul><li>Undefined, Null, Boolean, Number, String</li><li>Object是复杂数据类型, 其本质是由一组无序的名值对组成的.</li></ul><h3 id="20-基本类型与引用类型有什么区别"><a href="#20-基本类型与引用类型有什么区别" class="headerlink" title="20. 基本类型与引用类型有什么区别?"></a>20. 基本类型与引用类型有什么区别?</h3><ul><li>基本类型如上题所示. 引用类型则有: Object, Array, Date, RegExp, Function</li><li>存储<ul><li>基本类型值在内存中占据固定大小的空间,因此被保存在栈内存中</li><li>引用类型的值是对象, 保存在堆内存中. 包含引用类型的变量实际上包含的并不是对象本身, 而是一个指向改对象的指针　</li></ul></li><li>复制<ul><li>从一个变量向另一个变量复制基本类型的值, 会创建这个值的一个副本</li><li>从一个变量向另一个变量复制引用类型的值, 复制的其实是指针,　因此两个变量最终都指向同一个对象</li></ul></li><li>检测类型<ul><li>确定一个值是哪种基本类型可以用typeof操作符,</li><li>而确定一个值是哪种引用类型可以使用instanceof操作符</li></ul></li></ul><h3 id="21-关于js的垃圾收集例程"><a href="#21-关于js的垃圾收集例程" class="headerlink" title="21. 关于js的垃圾收集例程"></a>21. 关于js的垃圾收集例程</h3><p>　　js是一门具有自动垃圾回收机制的编程语言,开发人员不必关心内存分配和回收问题</p><ul><li>离开作用域的值将被自动标记为可以回收, 因此将在垃圾收集期间被删除</li><li>“标记清除”是目前主流的垃圾收集算法, 这种算法的思路是给当前不使用的值加上标记, 然后再回收其内存</li><li>另一种垃圾收集算法是”引用计数”, 这种算法的思想是跟踪记录所有值被引用的次数. js引擎目前都不再使用这种算法, 但在IE中访问非原生JS对象(如DOM元素)时, 这种算法仍然可能会导致问题</li><li>当代码中存在循环引用现象时, “引用计数” 算法就会导致问题</li><li>解除变量的引用不仅有助于消除循环引用现象, 而且对垃圾收集也有好处. 为了确保有效地回收内存, 应该及时解除不再使用的全局对象, 全局对象属性以及循环引用变量的引用</li></ul><h3 id="22-ES5中-除了函数-什么能够产生作用域"><a href="#22-ES5中-除了函数-什么能够产生作用域" class="headerlink" title="22. ES5中, 除了函数,什么能够产生作用域?"></a>22. ES5中, 除了函数,什么能够产生作用域?</h3><p>答: try-catch 和with延长作用域. 因为他们都会创建一个新的变量对象. </p><p>　　这两个语句都会在作用域链的前端添加一个变量对象. 对with语句来说, 会将指定的对象添加到作用域链中. 对catch语句来说, 会创建一个新的变量对象, 其中包含的是被抛出的错误对象的声明.</p><ul><li>当try代码块中发生错误时，执行过程会跳转到catch语句，然后把异常对象推入一个可变对象并置于作用域的头部。在catch代码块内部，函数的所有局部变量将会被放在第二个作用域链对象中。请注意，一旦catch语句执行完毕，作用域链机会返回到之前的状态。try-catch语句在代码调试和异常处理中非常有用，因此不建议完全避免。你可以通过优化代码来减少catch语句对性能的影响。一个很好的模式是将错误委托给一个函数处理</li><li>with(object) {statement}。它的意思是把object添加到作用域链的顶端<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = <span class="string">"?debug=true"</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//with接收location对象, 因此其变量对象中就包含了location对象的所有属性和方法, 而这个变量对象被添加到了作用域链的前端</span></span><br><span class="line">    <span class="keyword">with</span>(location)&#123;</span><br><span class="line">        <span class="comment">//这里的href其实是location.href. 创建了一个名为url的变量, 就成了函数执行环境的一部分</span></span><br><span class="line">        <span class="keyword">var</span> url = href + qs;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="23-js有几种函数调用方式"><a href="#23-js有几种函数调用方式" class="headerlink" title="23. js有几种函数调用方式?"></a>23. js有几种函数调用方式?</h3><ul><li>方法调用模型    var obj = { func : function(){};}    obj.func()</li><li>函数调用模式　　var func = function(){}    func();</li><li>构造器调用模式  </li><li>apply/ call调用模式</li></ul><h3 id="24-描述事件模型-IE的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？"><a href="#24-描述事件模型-IE的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？" class="headerlink" title="24. 描述事件模型?IE的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？"></a>24. 描述事件模型?IE的事件模型是怎样的？事件代理是什么？事件代理中怎么定位实际事件产生的目标？</h3><p>捕获-&gt;处于目标-&gt;冒泡，IE应该是只有冒泡没有捕获。</p><p>事件代理就是在父元素上绑定事件来处理，通过event对象的target来定位。</p><h3 id="25-js动画有哪些实现方法"><a href="#25-js动画有哪些实现方法" class="headerlink" title="25. js动画有哪些实现方法?"></a>25. js动画有哪些实现方法?</h3><p>用定时器 setTimeout和setInterval</p><h3 id="26-还有什么实现动画的方法"><a href="#26-还有什么实现动画的方法" class="headerlink" title="26. 还有什么实现动画的方法?"></a>26. 还有什么实现动画的方法?</h3><ul><li><p>js动画: 使用定时器</p></li><li><p>CSS : transition , animation</p><ul><li>transition 包含4种属性：transition-delaytransition-durationtransition-propertytransition-timing-function，对应动画的4种属性： 延迟、持续时间、对应css属性和缓动函数，</li><li>transform 包含7种属性：animation-nameanimation-durationanimation-timing-functionanimation-delayanimation-directionanimation-iteration-countanimation-fill-modeanimation-play-state，它们可以定义动画名称，持续时间，缓动函数，动画延迟，动画方向，重复次数，填充模式。</li></ul></li><li><p>HTML5 动画</p><ul><li>canvas</li><li>svg</li><li>webgl</li></ul></li></ul><h3 id="27-面向对象有哪几个特点"><a href="#27-面向对象有哪几个特点" class="headerlink" title="27. 面向对象有哪几个特点?"></a>27. 面向对象有哪几个特点?</h3><p>封装, 继承, 多态</p><h3 id="28-如何判断属性来自自身对象还是原型链"><a href="#28-如何判断属性来自自身对象还是原型链" class="headerlink" title="28. 如何判断属性来自自身对象还是原型链?"></a>28. 如何判断属性来自自身对象还是原型链?</h3><p>hasOwnPrototype</p><h3 id="29-ES6新特性"><a href="#29-ES6新特性" class="headerlink" title="29. ES6新特性"></a>29. ES6新特性</h3><ol><li>箭头操作符 inputs=&gt;outputs: 操作符左边是输入的参数，而右边则是进行的操作以及返回的值</li><li>支持类, 引入了class关键字. ES6提供的类实际上就是JS原型模式的包装</li><li>增强的对象字面量. <ol><li>可以在对象字面量中定义原型  <strong>proto</strong>: xxx  //设置其原型为xxx,相当于继承xxx</li><li>定义方法可以不用function关键字</li><li>直接调用父类方法</li></ol></li><li>字符串模板: ES6中允许使用反引号 ` 来创建字符串，此种方法创建的字符串里面可以包含由美元符号加花括号包裹的变量${vraible}。</li><li>自动解析数组或对象中的值。比如若一个函数要返回多个值，常规的做法是返回一个对象，将每个值做为这个对象的属性返回。但在ES6中，利用解构这一特性，可以直接返回一个数组，然后数组中的值会自动被解析到对应接收该值的变量中。</li><li>默认参数值: 现在可以在定义函数的时候指定参数的默认值了，而不用像以前那样通过逻辑或操作符来达到目的了。</li><li>不定参数是在函数中使用命名参数同时接收不定数量的未命名参数。在以前的JavaScript代码中我们可以通过arguments变量来达到这一目的。不定参数的格式是三个句点后跟代表所有不定参数的变量名。比如下面这个例子中，…x代表了所有传入add函数的参数。</li><li>拓展参数则是另一种形式的语法糖，它允许传递数组或者类数组直接做为函数的参数而不用通过apply。</li><li>let和const关键字: 可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。const则很直观，用来定义常量，即无法被更改值的变量。</li><li>for of值遍历 每次循环它提供的不是序号而是值。</li><li>iterator, generator</li><li>模块</li><li>Map, Set, WeakMap, WeakSet</li><li>Proxy可以监听对象身上发生了什么事情，并在这些事情发生后执行一些相应的操作。一下子让我们对一个对象有了很强的追踪能力，同时在数据绑定方面也很有用处。</li><li>Symbols Symbol 通过调用symbol函数产生，它接收一个可选的名字参数，该函数返回的symbol是唯一的。之后就可以用这个返回值做为对象的键了。Symbol还可以用来创建私有属性，外部无法直接访问由symbol做为键的属性值。</li><li>Math, Number, String, Object的新API</li><li>Promises是处理异步操作的一种模式</li></ol><h3 id="30-如何获取某个DOM节点，节点遍历方式"><a href="#30-如何获取某个DOM节点，节点遍历方式" class="headerlink" title="30. 如何获取某个DOM节点，节点遍历方式"></a>30. 如何获取某个DOM节点，节点遍历方式</h3><p>getElementById()  getElementsByTagName()</p><h3 id="31-用LESS如何给某些属性加浏览器前缀？"><a href="#31-用LESS如何给某些属性加浏览器前缀？" class="headerlink" title="31. 用LESS如何给某些属性加浏览器前缀？"></a>31. 用LESS如何给某些属性加浏览器前缀？</h3><p>可以自定义一个函数</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.border-radius</span>(@<span class="keyword">values</span>) &#123;</span><br><span class="line">  <span class="selector-tag">-webkit-border-radius</span>: @<span class="keyword">values</span>;</span><br><span class="line">     <span class="selector-tag">-moz-border-radius</span>: @<span class="keyword">values</span>;</span><br><span class="line">          <span class="selector-tag">border-radius</span>: @<span class="keyword">values</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  .border-radius(10px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32-js异步模式如何实现？"><a href="#32-js异步模式如何实现？" class="headerlink" title="32.  js异步模式如何实现？"></a>32.  js异步模式如何实现？</h3><p>答: <a href="http://www.cnblogs.com/haoyijing/p/5737951.html" target="_blank" rel="noopener">JavaScript异步编程的Promise模式</a></p><h3 id="33-图片预加载的实现"><a href="#33-图片预加载的实现" class="headerlink" title="33. 图片预加载的实现"></a>33. 图片预加载的实现</h3><ol><li><p>使用jQuery图片预加载插件Lazy Load</p><ol><li>加载jQuery, 与jquery.lazyload.js</li><li>设置图片的占位符为data-original, 给图片一个特别的标签,比如class=”.lazy”</li><li>然后延迟加载: $(‘img.lazy’).lazyload();这个函数可以选择一些参数: <ol><li>图片预先加载距离：threshold，通过设置这个值，在图片未出现在可视区域的顶部距离这个值时加载。</li><li>事件绑定加载的方式：event</li><li>图片限定在某个容器内：container</li></ol></li></ol></li><li><p>使用js实现图片加载: 就是new一个图片对象, 绑定onload函数, 赋值url</p></li><li><p>用CSS实现图片的预加载</p><ol><li>写一个CSS样式设置一批背景图片，然后将其隐藏</li><li>改进: 使用js来推迟预加载时间, 防止与页面其他内容一起加载</li></ol></li><li><p>用Ajax实现预加载</p><ol><li>其实就是通过ajax请求请求图片地址. 还可以用这种方式加载css,js文件等<h3 id="34-如果在同一个元素上绑定了两个click事件-一个在捕获阶段执行-一个在冒泡阶段执行-那么当触发click条件时-会执行几个事件-执行顺序是什么"><a href="#34-如果在同一个元素上绑定了两个click事件-一个在捕获阶段执行-一个在冒泡阶段执行-那么当触发click条件时-会执行几个事件-执行顺序是什么" class="headerlink" title="34. 如果在同一个元素上绑定了两个click事件, 一个在捕获阶段执行, 一个在冒泡阶段执行. 那么当触发click条件时, 会执行几个事件? 执行顺序是什么?"></a>34. 如果在同一个元素上绑定了两个click事件, 一个在捕获阶段执行, 一个在冒泡阶段执行. 那么当触发click条件时, 会执行几个事件? 执行顺序是什么?</h3></li></ol><p>　　我在回答这个题的时候说是两个事件, 先执行捕获的后执行冒泡的. 其实是不对的.</p></li></ol><p>　　绑定在目标元素上的事件是按照绑定的顺序执行的!!!!</p><p>　　即: 绑定在被点击元素的事件是按照代码顺序发生，其他元素通过冒泡或者捕获“感知”的事件，按照W3C的标准，先发生捕获事件，后发生冒泡事件。所有事件的顺序是：其他元素捕获阶段事件 -&gt; 本元素代码顺序事件 -&gt; 其他元素冒泡阶段事件 。</p><h3 id="35-js中怎么实现块级作用域"><a href="#35-js中怎么实现块级作用域" class="headerlink" title="35. js中怎么实现块级作用域?"></a>35. js中怎么实现块级作用域?</h3><ul><li><p>使用匿名函数, (立即执行函数)</p><ul><li>(function(){…})()</li></ul></li><li><p>或者es6</p><ul><li><p>块级作用域引入了两种新的声明形式,可以用它们定义一个只存在于某个语句块中的变量或常量.这两种新的声明关键字为:</p><ul><li>let: 语法上非常类似于var, 但定义的变量只存在于当前的语句块中</li><li>const: 和let类似,但声明的是一个只读的常量</li></ul></li></ul></li></ul><p>使用let代替var可以更容易的定义一个只在某个语句块中存在的局部变量,而不用担心它和函数体中其他部分的同名变量有冲突.在let语句内部用var声明的变量和在let语句外部用var声明的变量没什么差别,它们都拥有函数作用域,而不是块级作用域.</p><h3 id="36-构造函数里定义function和使用prototype-func的区别？"><a href="#36-构造函数里定义function和使用prototype-func的区别？" class="headerlink" title="36. 构造函数里定义function和使用prototype.func的区别？"></a>36. 构造函数里定义function和使用prototype.func的区别？</h3><ol><li>直接调用function，每一个类的实例都会拷贝这个函数，弊端就是浪费内存（如上）。prototype方式定义的方式，函数不会拷贝到每一个实例中，所有的实例共享prototype中的定义，节省了内存。</li><li>但是如果prototype的属性是对象的话，所有实例也会共享一个对象（这里问的是函数应该不会出现这个情况），如果其中一个实例改变了对象的值，则所有实例的值都会被改变。同理的话，如果使用prototype调用的函数，一旦改变，所有实例的方法都会改变。——不可以对实例使用prototype属性，只能对类和函数用。</li></ol><h3 id="37-js实现对象的深克隆"><a href="#37-js实现对象的深克隆" class="headerlink" title="37. js实现对象的深克隆"></a>37. js实现对象的深克隆</h3><p>因为js中数据类型分为基本数据类型(number, string, boolean, null, undefined)和引用类型值(对象, 数组, 函数). 这两类对象在复制克隆的时候是有很大区别的. 原始类型存储的是对象的实际数据, 而对象类型存储的是对象的引用地址(对象的实际内容单独存放, 为了减少数据开销通常放在内存中). 此外, 对象的原型也是引用对象, 它把原型的属性和方法放在内存中, 通过原型链的方式来指向这个内存地址. </p><p>于是克隆也会分为两类:</p><ol><li>浅度克隆: 原始类型为值传递, 对象类型仍为引用传递</li><li>深度克隆: 所有元素或属性均完全复制, 与原对象完全脱离, 也就是说所有对于新对象的修改都不会反映到原对象中</li></ol><p>深度克隆实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span>(obj)== <span class="string">'object'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> result = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            <span class="keyword">var</span> attr = obj[i];</span><br><span class="line">            result[i] = <span class="built_in">arguments</span>.callee(attr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  参考: <a href="http://www.cnblogs.com/rookiebob/p/3955078.html" target="_blank" rel="noopener">javascript中对象的深度克隆</a></p><h2 id="五、-一些编程题"><a href="#五、-一些编程题" class="headerlink" title="五、 一些编程题"></a>五、 一些编程题</h2><h3 id="1-var-obj-a-1-function-obj-obj-a-2-obj-问obj怎么变？"><a href="#1-var-obj-a-1-function-obj-obj-a-2-obj-问obj怎么变？" class="headerlink" title="1. var obj = {a : 1}; (function (obj) { obj = {a : 2}; })(obj); //问obj怎么变？"></a>1. var obj = {a : 1}; (function (obj) { obj = {a : 2}; })(obj); //问obj怎么变？</h3><p>外部的obj不变. 因为匿名函数中obj传入参数等于是创建了一个局部变量obj, 里面的obj指向了一个新的对象 . 如果改成(function () { obj = {a : 2}; })(obj);  就会变了</p><h3 id="2-var-obj-a-1-func-function-function-a-2-obj-fun-a-怎么变-匿名函数里的this-是什么"><a href="#2-var-obj-a-1-func-function-function-a-2-obj-fun-a-怎么变-匿名函数里的this-是什么" class="headerlink" title="2. var obj = { a:1,  func: function() { (function () { a=2; }(); }} ; obj.fun()   //a 怎么变? 匿名函数里的this 是什么?"></a>2. var obj = { a:1,  func: function() { (function () { a=2; }(); }} ; obj.fun()   //a 怎么变? 匿名函数里的this 是什么?</h3><p>obj里的a不会变. 匿名函数里的this指向全局对象window.  这等于是给window加了一个名为a的属性</p><p>　　要改变obj中a的值 , 应当:</p><p>　　(function() { this.a = 2}).call(this);</p><p>　　或者obj中定义func :    func: function() { var self = this; (function(){self.a=2;})();}</p><ol start="3"><li>要实现函数内每隔5秒调用自己这个函数，100次以后停止，怎么办</li></ol><h3 id="4-点击一个ul的五个li元素，分别弹出他们的序号，怎么做？"><a href="#4-点击一个ul的五个li元素，分别弹出他们的序号，怎么做？" class="headerlink" title="4. 点击一个ul的五个li元素，分别弹出他们的序号，怎么做？"></a>4. 点击一个ul的五个li元素，分别弹出他们的序号，怎么做？</h3><p>方法1 : </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;oLis.length; i++)&#123;</span><br><span class="line">    oLis[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话, 给每个li绑定onclick事件时, 其实绑的是一个立即执行函数, 这个立即执行函数的参数是i, 因为它是立即执行的, 循环时已经把i的值赋给了li的onclick事件, 所以在外部函数里的i改变后并不会影响i的值.</p><p>另一种实现方法:(立即执行函数)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;oLi.length; i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        oLi[j].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(j);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法2: </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">obj,i</span>)</span>&#123;</span><br><span class="line">    obj.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert (i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;oLi.length; i++)&#123;</span><br><span class="line">    func(oLi[i], i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3: 设置属性:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oLi = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;oLi.length; i++)&#123;</span><br><span class="line">    oLi[i].setAttribute(<span class="string">"onclick"</span>, <span class="string">"alert("</span>+i+<span class="string">");"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4: 设置index保存</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;oLi.length; i++)&#123;</span><br><span class="line">    oLi[i].index = i;</span><br><span class="line">    oLi[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、js算法题"><a href="#六、js算法题" class="headerlink" title="六、js算法题"></a>六、js算法题</h2><h3 id="1-js实现数组去重怎么实现"><a href="#1-js实现数组去重怎么实现" class="headerlink" title="1. js实现数组去重怎么实现?"></a>1. js实现数组去重怎么实现?</h3><p>方法1. 创建一个新的临时数组来保存数组中已有的元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = [];     <span class="comment">//一个新的临时数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="comment">//如果把当前数组的第i已经保存进了临时数组, 那么跳过</span></span><br><span class="line">        <span class="keyword">if</span>(n.indexOf(<span class="keyword">this</span>[i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.unique1());</span><br></pre></td></tr></table></figure><p>方法2. 使用哈希表存储已有的元素</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = &#123;&#125;,</span><br><span class="line">        n = [];     <span class="comment">//hash 作为哈希表, n为临时数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hash[<span class="keyword">this</span>[i]])&#123;         <span class="comment">//如果hash表中没有当前项</span></span><br><span class="line">            hash[<span class="keyword">this</span>[i]] = <span class="literal">true</span>;   <span class="comment">//存入hash表</span></span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);        <span class="comment">//当前元素push到临时数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法3. 使用indexOf判断数组元素第一次出现的位置是否为当前位置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = [<span class="keyword">this</span>[<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="keyword">this</span>.length; i++)    <span class="comment">//从第二项开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前数组元素在数组中出现的第一次的位置不是i</span></span><br><span class="line">        <span class="comment">//说明是重复元素</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) == i)&#123;</span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4. 先排序再去重</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; <span class="keyword">return</span> a - b;&#125;);</span><br><span class="line">    <span class="keyword">var</span> n = [<span class="keyword">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>[i] != <span class="keyword">this</span>[i<span class="number">-1</span>])&#123;</span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方法和第三种方法都使用了indexOf(), 这个函数的执行机制也会遍历数组</p><p>第二种方法使用了一个哈希表, 是最快的. </p><p>第三种方法也有一个排序的复杂度的计算.</p><p>然后做了个测试, 随机生成100万个0-1000的数组结果如下:</p><p>第三种方法总是第二种方法的将近两倍, 而第四种方法与数组的范围有关,</p><p>如果是0-100的数组</p><p>而如果是0-10000, 方法四看着就效果还不错了</p><p>而第二种方法永远是最好的, 但是是以空间换时间</p><p>全部代码如下:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">1000000</span>; i++)&#123;</span><br><span class="line">    a.push(<span class="built_in">Math</span>.ceil(<span class="built_in">Math</span>.random()*<span class="number">10000</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = [];     <span class="comment">//一个新的临时数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="comment">//如果把当前数组的第i已经保存进了临时数组, 那么跳过</span></span><br><span class="line">        <span class="keyword">if</span>(n.indexOf(<span class="keyword">this</span>[i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = &#123;&#125;,</span><br><span class="line">        n = [];     <span class="comment">//hash 作为哈希表, n为临时数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!hash[<span class="keyword">this</span>[i]])&#123;         <span class="comment">//如果hash表中没有当前项</span></span><br><span class="line">            hash[<span class="keyword">this</span>[i]] = <span class="literal">true</span>;   <span class="comment">//存入hash表</span></span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);        <span class="comment">//当前元素push到临时数组中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Array</span>.prototype.unique3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = [<span class="keyword">this</span>[<span class="number">0</span>]]; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="keyword">this</span>.length; i++)    <span class="comment">//从第二项开始遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前数组元素在数组中出现的第一次的位置不是i</span></span><br><span class="line">        <span class="comment">//说明是重复元素</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) == i)&#123;</span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">Array</span>.prototype.unique4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; <span class="keyword">return</span> a - b;&#125;);</span><br><span class="line">    <span class="keyword">var</span> n = [<span class="keyword">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>[i] != <span class="keyword">this</span>[i<span class="number">-1</span>])&#123;</span><br><span class="line">            n.push(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> begin1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">a.unique1();</span><br><span class="line"><span class="keyword">var</span> end1 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> begin2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">a.unique2();</span><br><span class="line"><span class="keyword">var</span> end2 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> begin3 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">a.unique3();</span><br><span class="line"><span class="keyword">var</span> end3 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> begin4 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">a.unique4();</span><br><span class="line"><span class="keyword">var</span> end4 = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法一执行时间:"</span> + (end1 - begin1));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法二执行时间:"</span> + (end2 - begin2));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法三执行时间:"</span> + (end3 - begin3));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法四执行时间:"</span> + (end4 - begin4));</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 复习一 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自动化构建工具</title>
      <link href="/2019/07/23/webpack/"/>
      <content type="html"><![CDATA[<p>使用构建工具去对 JS、CSS、HTML、LESS、IMG 等进行合并压缩构建到实现自动化构建项目。</p><a id="more"></a><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>本质上，webpack是一个现代JavaScript应用程序的静态模块打包器(module bundler)。当webpack处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。</p><h4 id="了解Webpack相关"><a href="#了解Webpack相关" class="headerlink" title="了解Webpack相关"></a>了解Webpack相关</h4><ol><li><p>什么是webpack</p><ul><li><p>Webpack是一个模块打包器(bundler)。</p></li><li><p>在Webpack看来, 前端的所有资源文件(js/css/img/less/…)都会作为模块处理</p></li><li><p>它将根据模块的依赖关系进行静态分析，生成对应的静态资源</p></li></ul></li></ol><p>​      </p><ol start="2"><li><p>理解Loader</p><ul><li><p>Webpack 本身只能加载JS模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载</p></li><li><p>Loader 本身也是运行在 node.js 环境中的 JavaScript 模块</p></li><li><p>它本身是一个函数，接受源文件作为参数，返回转换的结果</p></li><li><p>loader 一般以 xxx-loader 的方式命名，xxx 代表了这个 loader 要做的转换功能，比如 json-loader。</p></li></ul></li></ol><p>​      </p><ol start="3"><li><p>配置文件(默认)</p><ul><li>webpack.config.js : 是一个node模块，返回一个 json 格式的配置信息对象</li></ul></li></ol><p>​      </p><ol start="4"><li><p>插件</p><ul><li><p>插件件可以完成一些loader不能完成的功能。</p></li><li><p>插件的使用一般是在 webpack 的配置信息 plugins 选项中指定。</p></li><li><p>Webpack 本身内置了一些常用的插件，还可以通过 npm 安装第三方插件</p></li></ul></li></ol><p>​      </p><h4 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档 :"></a>学习文档 :</h4><ul><li><p>webpack官方入门: <a href="http://webpack.github.io/docs/tutorials/getting-started/" target="_blank" rel="noopener">http://webpack.github.io/docs/tutorials/getting-started/</a></p></li><li><p>Webpack中文指南: <a href="http://zhaoda.net/webpack-handbook/index.html" target="_blank" rel="noopener">http://zhaoda.net/webpack-handbook/index.html</a></p></li></ul><h4 id="你将学到"><a href="#你将学到" class="headerlink" title="你将学到:"></a>你将学到:</h4><ol><li><p>How to install webpack</p></li><li><p>How to use webpack</p></li><li><p>How to use loaders</p></li><li><p>How to use the development server</p></li><li><p>How to use image</p></li></ol><p>​    </p><h4 id="初始化项目-package-json"><a href="#初始化项目-package-json" class="headerlink" title="初始化项目: package.json"></a>初始化项目: package.json</h4>  <figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack_test"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h4>  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">npm install <span class="symbol">webpack@</span><span class="number">1</span> -g  <span class="comment">//全局安装</span></span><br><span class="line">npm install <span class="symbol">webpack@</span><span class="number">1</span> --save-dev  <span class="comment">//局部安装</span></span><br></pre></td></tr></table></figure><h4 id="使用webpack配置文件"><a href="#使用webpack配置文件" class="headerlink" title="使用webpack配置文件"></a>使用webpack配置文件</h4><ol><li><p>创建webpack.config.js</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">"./src/js/entry.js"</span>,<span class="comment">//入口路径配置</span></span><br><span class="line">  output: &#123;<span class="comment">//出口配置</span></span><br><span class="line">      path: __dirname + <span class="string">'/build/js'</span>,<span class="comment">//输出路径</span></span><br><span class="line">      filename: <span class="string">"bundle.js"</span><span class="comment">//输出文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">module</span>: &#123;</span><br><span class="line">    loaders: [<span class="comment">//模块加载器配置</span></span><br><span class="line">      &#123; test: <span class="regexp">/\.css$/</span>, loader: <span class="string">"style!css"</span>&#125;  <span class="comment">//所有css文件声明使用css-loader和style-loader加载器</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">webpack</span><br><span class="line">webpack <span class="params">--progress</span>   <span class="string">//</span>编译显示进度</span><br></pre></td></tr></table></figure></li><li><p>问题——每次修改模块文件内容的重新手动打包，刷新</p></li><li><p>自动编译</p><p>webpack –watch  //编译并启动监视(但需要刷新浏览器)</p></li><li><p>浏览器自动刷新(热加载)—-解决手动刷新浏览器问题</p><p>npm install webpack-dev-server@1 -g<br>webpack-dev-server<br> 访问: <a href="http://localhost:8080/webpack-dev-server/；" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server/；</a><br> <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p> !!!发现问题—-访问的是文件夹路径而不是页面<br>   devServer:{</p><pre><code>    contentBase: &apos;./build&apos;,//内置服务器动态加载页面所在的目录    historyApiFallback:true,//不跳转    inline:true}</code></pre><p>   contentBase : 默认webpack-dev-server为根文件夹提供内置的服务，如果其他目录下的文件</p><pre><code>提供服务需要在此设置目录(我们设置为build文件夹)</code></pre><p>   historyApiFallback : 开发单页面的时候非常有用，它依赖于H5的 history API，当</p><pre><code>设置为true的时候所有的跳转都指向index.html；</code></pre><p>   port：可以设置端口号，不设置时候默认为 8080<br>   inline ： 设置为true的时候回自动刷新(有的版本需要配合hot : true使用)</p><p> webpack-dev-server<br> 访问: <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p><p>问题：页面没有热加载，自动刷新，因为index的src引入的硬盘中的build文件而不是webpack-dev-server服务器内存中的build<br>特点:<br> 自动编译并刷新界面<br> 不生成编译后的文件, 直接在内存中编译处理, 并启动服务器运行项目</p></li></ol><h4 id="配置npm-script命令"><a href="#配置npm-script命令" class="headerlink" title="配置npm script命令"></a>配置npm script命令</h4>  <figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"start"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">npm</span> start: 编译运行项目</span><br><span class="line"><span class="built_in">npm</span> build: 编译打包</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Less</title>
      <link href="/2019/07/08/Less/"/>
      <content type="html"><![CDATA[<p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</p><a id="more"></a><h3 id="CSS预处理——less"><a href="#CSS预处理——less" class="headerlink" title="CSS预处理——less"></a>CSS预处理——less</h3><p>less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展LESS 既可以在 客户端 上运行，也可以借助Node.js在服务端运行。</p><pre><code>less的中文官网：http://lesscss.cn/bootstrap中less教程：http://www.bootcss.com/p/lesscss/</code></pre><h4 id="Less编译工具"><a href="#Less编译工具" class="headerlink" title="Less编译工具"></a>Less编译工具</h4><p><a href="www.koala-app.com">koala官网</a></p><h4 id="less中的注释"><a href="#less中的注释" class="headerlink" title="less中的注释"></a>less中的注释</h4><ul><li>以//开头的注释，不会被编译到css文件中</li></ul><ul><li>以/**/包裹的注释会被编译到css文件中 </li></ul><p>   ​    </p><h4 id="less中的变量"><a href="#less中的变量" class="headerlink" title="less中的变量"></a>less中的变量</h4><p>使用@来申明一个变量：@pink：pink;</p><ol><li><p>作为普通属性值只来使用：直接使用@pink</p></li><li><p>作为选择器和属性名：#@{selector的值}的形式</p></li><li><p>作为URL：@{url}</p></li><li><p>变量的延迟加载</p></li></ol><h4 id="less中的嵌套规则"><a href="#less中的嵌套规则" class="headerlink" title="less中的嵌套规则"></a>less中的嵌套规则</h4><ol><li><p>基本嵌套规则</p></li><li><p>&amp;的使用</p></li></ol><h4 id="less中的混合"><a href="#less中的混合" class="headerlink" title="less中的混合"></a>less中的混合</h4><p>混合就是将一系列属性从一个规则集引入到另一个规则集的方式</p><ol><li><p>普通混合（编译到原生CSS中的）  </p></li><li><p>不带输出的混合</p></li><li><p>带参数的混合</p></li><li><p>带参数并且有默认值的混合</p></li><li><p>带多个参数的混合</p></li><li><p>命名参数</p></li><li><p>匹配模式</p></li><li><p>arguments变量</p></li></ol><h4 id="less运算"><a href="#less运算" class="headerlink" title="less运算"></a>less运算</h4><ol><li><p>在less中可以进行加减乘除的运算</p></li><li><p>计算的一方带单位</p></li></ol><h4 id="less继承"><a href="#less继承" class="headerlink" title="less继承"></a>less继承</h4><ol><li><p>性能比混合高</p></li><li><p>灵活度比混合低</p></li></ol><h4 id="less避免编译"><a href="#less避免编译" class="headerlink" title="less避免编译"></a>less避免编译</h4>]]></content>
      
      
        <tags>
            
            <tag> less </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS模块化规范</title>
      <link href="/2019/06/28/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
      <content type="html"><![CDATA[<p>当项目功能越来越多，代码量便也会越来越多，后期的维护难度会增大，此时在JS方面就会考虑使用模块化规范去管理。</p><a id="more"></a><h3 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h3><ol><li><p>什么是模块?</p><ul><li><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</p></li><li><p>块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p></li></ul></li></ol><ol start="2"><li><p>一个模块的组成</p><ul><li><p>数据—&gt;内部的属性</p></li><li><p>操作数据的行为—&gt;内部的函数</p></li></ul></li></ol><ol start="3"><li><p>模块化</p><ul><li>编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目</li></ul></li></ol><ol start="4"><li>模块化的进化过程<ul><li>全局function模式 : <ul><li>编码: 全局变量/函数</li><li>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</li></ul></li><li>namespace模式 : <ul><li>编码: 将数据/行为封装到对象中</li><li>解决: 命名冲突(减少了全局变量)</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li><li>IIFE模式/增强<ul><li>IIFE : 立即调用函数表达式—&gt;匿名函数自调用</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>引入依赖: 通过函数形参来引入依赖模块<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">function</span>(<span class="name">window</span>, module2)&#123;</span><br><span class="line">  var data = 'atguigu.com'</span><br><span class="line">  function foo() &#123;</span><br><span class="line">     module2.xxx()</span><br><span class="line">     console.log(<span class="name">'foo</span>()'+data)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">     console.log(<span class="name">'bar</span>()'+data)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  window.module = &#123;foo&#125;</span><br><span class="line">&#125;)(<span class="name">window</span>, module2)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h3><ol><li><p><strong>CommonJS</strong></p><ul><li><p>Node.js : 服务器端</p></li><li><p>Browserify : 浏览器端    也称为js的打包工具</p></li><li><p>基本语法:</p><ul><li>定义暴露模块 : exports<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">exports.xxx</span> = value</span><br><span class="line"><span class="attr">module.exports</span> = value</span><br></pre></td></tr></table></figure></li></ul><p>引入模块 : require</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'模块名/模块相对路径'</span>)</span><br></pre></td></tr></table></figure></li><li><p>引入模块发生在什么时候?</p><ul><li><p>Node : 运行时, 动态同步引入</p></li><li><p>Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), </p><pre><code>运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块</code></pre></li></ul></li></ul></li></ol><p>​           </p><ol start="2"><li><p><strong>AMD : 浏览器端</strong></p><ul><li>require.js</li><li>基本语法<ul><li>定义暴露模块: define([依赖模块名], function(){return 模块对象})</li><li>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</li><li>配置: <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">  <span class="comment">//基本路径</span></span><br><span class="line">  <span class="string">baseUrl :</span> <span class="string">'js/'</span>,</span><br><span class="line">  <span class="comment">//标识名称与路径的映射</span></span><br><span class="line">  <span class="string">paths :</span> &#123;</span><br><span class="line">    <span class="string">'模块1'</span> : <span class="string">'modules/模块1'</span>,</span><br><span class="line">    <span class="string">'模块2'</span> : <span class="string">'modules/模块2'</span>,</span><br><span class="line">    <span class="string">'angular'</span> : <span class="string">'libs/angular'</span>,</span><br><span class="line">    <span class="string">'angular-messages'</span> : <span class="string">'libs/angular-messages'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//非AMD的模块</span></span><br><span class="line">  <span class="string">shim :</span> &#123;</span><br><span class="line">    <span class="string">'angular'</span> : &#123;</span><br><span class="line">        <span class="string">exports :</span> <span class="string">'angular'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'angular-messages'</span> : &#123;</span><br><span class="line">        <span class="string">exports :</span> <span class="string">'angular-messages'</span>,</span><br><span class="line">        <span class="string">deps :</span> [<span class="string">'angular'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><p>​    </p><ol start="3"><li><p><strong>CMD : 浏览器端</strong></p><ul><li>sea.js</li><li>基本语法<ul><li>定义暴露模块: <figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">define(function(<span class="keyword">require</span>, <span class="class"><span class="keyword">module</span>, <span class="title">exports</span>)&#123;</span></span><br><span class="line">  通过<span class="keyword">require</span>引入依赖模块</span><br><span class="line">  通过<span class="class"><span class="keyword">module</span>/<span class="title">exports</span>来暴露模块</span></span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><pre><code>* 使用模块seajs.use([&apos;模块1&apos;, &apos;模块2&apos;])</code></pre><p>​        </p><ol start="4"><li><p><strong>ES6</strong></p><ul><li><p>ES6内置了模块化的实现</p></li><li><p>基本语法</p></li><li><p>定义暴露模块 : export</p><ul><li><p>暴露一个对象: </p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>对象</span><br></pre></td></tr></table></figure></li><li><p>暴露多个: </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> xxx = value1</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> yyy = value2</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx = value1</span><br><span class="line"><span class="keyword">let</span> yyy = value2</span><br><span class="line"><span class="keyword">export</span> &#123;xxx, yyy&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><pre><code>  * 引入使用模块 : import    * default模块:      <figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx  <span class="keyword">from</span> <span class="string">'模块路径/模块名'</span></span><br></pre></td></tr></table></figure>    * 其它模块      <figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;xxx, yyy&#125; <span class="keyword">from</span> <span class="string">'模块路径/模块名'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> module1 <span class="keyword">from</span> <span class="string">'模块路径/模块名'</span></span><br></pre></td></tr></table></figure>* 问题: 所有浏览器还不能直接识别ES6模块化的语法  * 解决:    * 使用Babel将ES6---&gt;ES5(使用了CommonJS) ----浏览器还不能直接支行    * 使用Browserify---&gt;打包处理----浏览器可以运行</code></pre>]]></content>
      
      
        <tags>
            
            <tag> JS模块化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECMAScript</title>
      <link href="/2019/06/10/ECMAScript/"/>
      <content type="html"><![CDATA[<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript</a>(俗称: ES5, ES6)规范、尤其ES6是JavaScript 语言的下一代标准，它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><a id="more"></a><h3 id="理解ES"><a href="#理解ES" class="headerlink" title="理解ES"></a><strong>理解ES</strong></h3><ol><li>全称: ECMAScript</li><li>js语言的规范</li><li>我们用的js是它的实现</li><li>js的组成<ul><li>ECMAScript(js基础)</li><li>扩展–&gt;浏览器端<ul><li>BOM</li><li>DOM</li></ul></li><li>扩展–&gt;服务器端<ul><li>Node.js</li></ul></li></ul></li></ol><p>​      </p><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><ol><li><p><strong>严格模式</strong></p><ul><li><p>运行模式: 正常(混杂)模式与严格模式</p></li><li><p>应用上严格式: ‘strict mode’;</p></li><li><p>作用: </p><ul><li><p>使得Javascript在更严格的条件下运行</p></li><li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全</p></li><li><p>需要记住的几个变化</p><ul><li><p>声明定义变量必须用var</p></li><li><p>禁止自定义的函数中的this关键字指向全局对象</p></li><li><p>创建eval作用域, 更安全</p></li></ul></li></ul></li></ul></li></ol><ol start="2"><li><p><strong>JSON对象</strong></p><ul><li><p>作用: 用于在json对象/数组与js对象/数组相互转换</p></li><li><p>JSON.stringify(obj/arr)<br> js对象(数组)转换为json对象(数组)</p></li><li><p>JSON.parse(json)<br> json对象(数组)转换为js对象(数组)</p></li></ul></li></ol><ol start="3"><li><p><strong>Object扩展</strong></p><ul><li><p>Object.create(prototype[, descriptors]) : 创建一个新的对象</p><ul><li>以指定对象为原型创建新的对象</li><li>指定新的属性, 并对属性进行描述<ul><li>value : 指定值</li><li>writable : 标识当前属性值是否是可修改的, 默认为true</li><li><strong>get方法</strong> : 用来得到当前属性值的回调函数</li><li><strong>set方法</strong> : 用来监视当前属性值变化的回调函数</li></ul></li></ul></li><li><p>Object.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性</p></li></ul></li></ol><ol start="4"><li><p><strong>Array扩展</strong></p><ul><li><p>Array.prototype.indexOf(value) : 得到值在数组中的第一个下标</p></li><li><p>Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</p></li><li><p><strong>Array.prototype.forEach(function(item, index){}) : 遍历数组</strong></p></li><li><p><strong>Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组</strong></p></li><li><p><strong>Array.prototype.filter(function(item, index){}) : 遍历过滤出一个子数组</strong></p></li></ul></li></ol><ol start="5"><li><p><strong>Function扩展</strong></p><ul><li><p>Function.prototype.bind(obj)</p><ul><li>将函数内的this绑定为obj, 并将函数返回</li></ul></li><li><p>面试题: 区别bind()与call()和apply()?</p><ul><li><p>fn.bind(obj) : 指定函数中的this, 并返回函数</p></li><li><p>fn.call(obj) : 指定函数中的this,并调用函数</p></li></ul></li></ul></li></ol><ol start="6"><li><strong>Date扩展</strong><ul><li>Date.now() : 得到当前时间值</li></ul></li></ol><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ol><li><p><strong>2个新的关键字</strong></p><ul><li><p>let/const</p></li><li><p>块作用域</p></li><li><p>没有变量提升</p></li><li><p>不能重复定义</p></li><li><p>值不可变</p></li></ul></li></ol><ol start="2"><li><p><strong>变量的解构赋值</strong></p><ul><li><p>将包含多个数据的对象(数组)一次赋值给多个变量</p></li><li><p>数据源: 对象/数组</p></li><li><p>目标: {a, b}/[a, b]</p></li></ul></li></ol><ol start="3"><li><p><strong>各种数据类型的扩展</strong></p><ul><li><p>字符串</p><ul><li><strong>模板字符串</strong> <ul><li>作用: 简化字符串的拼接</li><li>模板字符串必须用``</li><li>变化的部分使用${xxx}定义</li></ul></li><li>contains(str) : 判断是否包含指定的字符串</li><li>startsWith(str) : 判断是否以指定字符串开头</li><li>endsWith(str) : 判断是否以指定字符串结尾</li><li>repeat(count) : 重复指定次数</li></ul></li><li><p>对象</p><ul><li><p><strong>简化的对象写法</strong></p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> name</span> = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">   <span class="built_in"> name</span>,</span><br><span class="line">    age,</span><br><span class="line">    setName <span class="built_in">(name</span>) &#123;</span><br><span class="line">        this<span class="built_in">.name</span> =<span class="built_in"> name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Object.assign(target, source1, source2..) : 将源对象的属性复制到目标对象上</p></li><li><p>Object.is(v1, v2) : 判断2个数据是否完全相等</p></li><li><p><strong>proto</strong>属性 : 隐式原型属性</p></li></ul></li><li><p>数组</p><ul><li>Array.from(v) : 将伪数组对象或可遍历对象转换为真数组</li><li>Array.of(v1, v2, v3) : 将一系列值转换成数组</li><li>find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素</li><li>findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标</li></ul></li><li><p>函数</p><ul><li><p><strong>箭头函数</strong></p><ul><li>用来定义匿名函数</li><li>基本语法:<ul><li>没有参数: () =&gt; console.log(‘xxxx’)</li><li>一个参数: i =&gt; i+2</li><li>大于一个参数: (i,j) =&gt; i+j</li><li>函数体不用大括号: 默认返回结果</li><li>函数体如果有多个语句, 需要用{}包围</li></ul></li><li>使用场景: 多用来定义回调函数</li></ul></li><li><p><strong>形参的默认值</strong></p><ul><li>定义形参时指定其默认的值</li></ul></li><li><p><strong>rest(可变)参数</strong></p><ul><li>通过形参左侧的…来表达, 取代arguments的使用</li></ul></li><li><p><strong>扩展运算符(…)</strong></p><ul><li>可以分解出数组或对象中的数据</li></ul></li></ul></li></ul></li></ol><ol start="4"><li><p><strong>set/Map容器结构</strong></p><ul><li><p>容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法</p></li><li><p>任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数)</p></li><li><p><strong>Set的特点</strong>: 保存多个value, value是不重复 ====&gt;数组元素去重</p></li><li><p><strong>Map的特点</strong>: 保存多个key–value, key是不重复, value是可以重复的</p></li><li><p>API</p><ul><li><p>Set()/Set(arr)  //arr是一维数组</p></li><li><p>add(value)</p></li><li><p>delete(value)</p></li><li><p>clear();</p></li><li><p>has(value)</p></li><li><p>size</p></li><li></li><li><p>Map()/Map(arr)  //arr是二维数组</p></li><li><p>set(key, value)</p></li><li><p>delete(key)</p></li><li><p>clear()</p></li><li><p>has(key)</p></li><li><p>size</p></li></ul></li></ul></li></ol><ol start="5"><li><p><strong>for–of循环</strong></p><ul><li><p>可以遍历任何容器</p></li><li><p>数组</p></li><li><p>对象</p></li><li><p>伪/类对象</p></li><li><p>字符串</p></li><li><p>可迭代的对象</p></li></ul></li></ol><ol start="6"><li><p><strong>Promise</strong></p><ul><li><p>解决<code>回调地狱</code>(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差)</p></li><li><p>能以同步编码的方式实现异步调用</p></li><li><p>在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise</p></li><li><p>ES6中定义实现API: </p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建promise对象</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 做异步的操作 </span></span><br><span class="line">  <span class="keyword">if</span>(成功) &#123; <span class="comment">// 调用成功的回调</span></span><br><span class="line">    resolve(result); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 调用失败的回调</span></span><br><span class="line">    reject(errorMsg); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// 2. 调用promise对象的then()</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  result =&gt; <span class="built_in">console</span>.log(result), </span></span></span><br><span class="line"><span class="function"><span class="params">  errorMsg =&gt; alert(errorMsg)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>))</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>class类</strong></p><ul><li>用 class 定义一类</li><li>用 constructor() 定义构造方法(相当于构造函数)</li><li>一般方法: xxx () {}</li><li>用extends来定义子类</li><li>用super()来父类的构造方法</li><li>子类方法自定义: 将从父类中继承来的方法重新实现一遍</li><li>js中没有方法重载(方法名相同, 但参数不同)的语法</li></ul></li></ol><h3 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h3><ul><li><p>指数运算符: **</p></li><li><p>Array.prototype.includes(value) : 判断数组中是否包含指定value</p></li><li><p><strong>区别方法的2种称谓</strong></p><ul><li>静态(工具)方法<ul><li>Fun.xxx = function(){}</li></ul></li><li>实例方法<ul><li>所有实例对象 : Fun.prototype.xxx = function(){} //xxx针对Fun的所有实例对象</li><li>某个实例对象 : fun.xxx = function(){} //xxx只是针对fun对象</li></ul></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> ES5_6_7 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ajax初识</title>
      <link href="/2019/05/25/ajax%E5%88%9D%E8%AF%86/"/>
      <content type="html"><![CDATA[<p>AJAX就是浏览器提供的一套API，可以通过代码控制请求与响应，实现网络编程。</p><a id="more"></a><h3 id="发送Ajax请求步骤"><a href="#发送Ajax请求步骤" class="headerlink" title="发送Ajax请求步骤"></a>发送Ajax请求步骤</h3><ol><li>创建XMLHttpRequest对象</li><li>准备发送</li><li>执行发送动作</li><li>指定回调函数</li></ol><p><img src="/resource/ajax.png" alt="ajax—回调函数"></p><p><strong>get：</strong></p><ul><li>get请求参数在url中传递</li><li>需要注意编码问题</li></ul><p><strong>post：</strong></p><ul><li>post请求参数在请求体中传递</li><li>需要设置请求头信息</li></ul><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>页面加载的同步与异步（白屏与不刷新）</p><ol><li>普通的页面效果：w3school.org</li><li>页面不刷新效果：评论加载</li></ol><p>描述两者之间的行为方式</p><ol><li><strong>同步</strong> 彼此等待 — 阻塞</li><li><strong>异步</strong>  各做各的 —  非阻塞</li></ol><h3 id="ajax的封装"><a href="#ajax的封装" class="headerlink" title="ajax的封装"></a>ajax的封装</h3><p>默认参数</p><p>出来形参，传递参数的时候覆盖默认参数，不传递就使用默认参数</p><ol><li><p>创建XMLHttpRequest对象</p><p>把对象形式的参数转化为字符串形式的参数</p><p>处理get请求参数并且处理中文乱码问题</p></li></ol><ol start="2"><li><p>准备发送（设置发送的参数）</p><p>处理post请求参数并且设置请求头信息（必须设置）</p></li></ol><ol start="3"><li><p>执行发送动作</p><p>处理同步请求，不会调用回调函数  </p></li></ol><ol start="4"><li>指定回调函数（处理服务器响应数据）</li></ol><h3 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h3><p><strong>同源策略</strong></p><ol><li><p>同源策略是浏览器的一种安全策略，所谓同源指的是请求URL地址中的协议、域名和端口都相同，只要其中之一不相同就是跨域</p></li><li><p>同源策略主要为了保证浏览器的安全性</p></li><li><p>在同源策略下，浏览器不允许Ajax跨域获取服务器数据</p></li></ol><h3 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h3><ol><li>静态script标签的src属性进行跨域请求</li><li>动态创建script标签，通过标签的src属性发送请求</li></ol>]]></content>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络概念</title>
      <link href="/2019/05/03/%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/"/>
      <content type="html"><![CDATA[<p><img src="/resource/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.png" alt="网络相关概念"></p><a id="more"></a><h3 id="客户端与服务器"><a href="#客户端与服务器" class="headerlink" title="客户端与服务器"></a>客户端与服务器</h3><p>本质上都是计算机，只不过样子不同，配置不同，应用场景不同（安装的应用软件不同）</p><ol><li>客户端主要用于普通上网用户</li><li>服务器主要给上网用户提供后台服务</li></ol><h3 id="网络相关概念"><a href="#网络相关概念" class="headerlink" title="网络相关概念"></a>网络相关概念</h3><ol><li>IP地址（唯一的确定互联网上的一台计算机）</li><li>域名 IP地址的别名，方便记忆</li><li>DNS 用于维护IP地址与域名的关系</li><li>端口 用来确定计算机上的网络应用程序</li></ol><h3 id="通信协议理解"><a href="#通信协议理解" class="headerlink" title="通信协议理解"></a>通信协议理解</h3><p><img src="/resource/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.png" alt="通信协议"></p><p><strong>通信双方约定的规则</strong></p><ol><li>http/https 超为本传输协议</li><li>ftp 文件传输协议</li><li>smpt/pop3 邮件收发协议</li><li>……</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 网络概念 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端SEO优化</title>
      <link href="/2019/04/28/%E5%89%8D%E7%AB%AFSEO%E4%BC%98%E5%8C%96/"/>
      <content type="html"><![CDATA[<p>SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。</p><a id="more"></a><h4 id="一、-搜索引擎工作原理"><a href="#一、-搜索引擎工作原理" class="headerlink" title="一、 搜索引擎工作原理"></a>一、 搜索引擎工作原理</h4><p>在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从茫茫的互联网上一点一点下载收集而来的。随着各种各样网站的出现，这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中。反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。</p><p>一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。这样一个过程我们称之为SEO。</p><h4 id="二、-SEO简介"><a href="#二、-SEO简介" class="headerlink" title="二、 SEO简介"></a>二、 SEO简介</h4><p>SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。</p><p>分类：白帽SEO和黑帽SEO。白帽SEO，起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。黑帽SEO，利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO，那么白帽SEO能做什么呢？</p><ol><li>对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；</li><li>网站内容优化：内容与关键字的对应，增加关键字的密度；</li><li>在网站上合理设置Robot.txt文件；</li><li>生成针对搜索引擎友好的网站地图；</li><li>增加外部链接，到各个网站上宣传。</li></ol><h4 id="三、-为什么要做SEO"><a href="#三、-为什么要做SEO" class="headerlink" title="三、 为什么要做SEO"></a>三、 为什么要做SEO</h4><p>提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。</p><h4 id="四、-前端SEO规范"><a href="#四、-前端SEO规范" class="headerlink" title="四、 前端SEO规范"></a>四、 前端SEO规范</h4><p>前端是构建网站中很重要的一个环节，前端的工作主要是负责页面的HTML+CSS+JS，优化好这几个方面会为SEO工作打好一个坚实的基础。通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂（提升用户体验），也能让“蜘蛛”看懂（提高搜索引擎友好度）。</p><p><strong>前端SEO注意事项：</strong></p><p>1、 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构</p><p>一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬了。并且根据相关数据调查：如果访客经过跳转3次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。为此我们需要做到：</p><p>（1）控制首页链接数量</p><p>网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。</p><p>（2）扁平化的目录层次</p><p>尽量让“蜘蛛”只要跳转3次，就能到达网站内的任何一个内页。</p><p>（3）导航优化</p><p>导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，<img>标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。</p><p>其次，在每一个网页上应该加上面包屑导航，好处：从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置，帮助用户很快了解网站组织形式，从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作；对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率。</p><p>（4）网站的结构布局—不可忽略的细节</p><p>页面头部：logo及主导航，以及用户的信息。</p><p>页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重</p><p>页面底部：版权信息和友情链接。</p><p><strong>特别注意：</strong>分页导航写法，推荐写法：“首页 1 2 3 4 5 6 7 8 9 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转。而下面的写法是不推荐的，“首页 下一页 尾页”，特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃。</p><p>（5）利用布局，把重要内容HTML代码放在最前</p><p>搜索引擎抓取HTML内容是从上到下，利用这一特点，可以让主要代码优先读取，广告等不重要代码放在下边。例如，在左栏和右栏的代码不变的情况下，只需改一下样式，利用float:left;和float:right;就可以随意让两栏在展现上位置互换，这样就可以保证重要代码在最前，让爬虫最先抓取。同样也适用于多栏的情况。</p><p>（6）控制页面的大小，减少http请求，提高网站的加载速度。</p><p>一个页面最好不要超过100k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。</p><p>2、网页代码优化</p><p>（1）突出重要内容—合理的设计title、description和keywords</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的<span class="tag">&lt;<span class="name">title</span>&gt;</span>标题中不要设置相同的内容。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">keywords</span>&gt;</span>标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">description</span>&gt;</span>标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。</span><br></pre></td></tr></table></figure><p>（2）语义化书写HTML代码，符合W3C标准</p><p>尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。比如：h1-h6 是用于标题类的，nav标签是用来设置页面主导航，列表形式的代码使用ul或ol，重要的文字使用strong等。</p><p>（3）a标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el=”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.360.cn"</span> <span class="attr">title</span>=<span class="string">"360安全中心"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）正文标题要用h1标签：h1标签自带权重“蜘蛛” 认为它最重要，一个页面有且最多只能有一个H1标签，放在该页面最重要的标题上面，如首页的logo上可以加H1标签。副标题用h2标签, 而其它地方不应该随便乱用 h 标题标签。</p><p>（5）img应使用 “alt” 属性加以说明</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cat.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"猫"</span>  /&gt;</span></span><br></pre></td></tr></table></figure><p>当网络速度很慢，或者图片地址失效的时候，就可以体现出alt属性的作用，他可以让用户在图片没有显示的时候知道这个图片的作用。同时为图片设置高度和宽度，可提高页面的加载速度。</p><p>（6）表格应该使用caption表格标题标签</p><p>caption 元素定义表格标题。caption 标签必须紧随 table 标签之后，您只能对每个表格定义</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">'1'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>banana<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>200<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（7）br标签：只用于文本内容的换行，比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><br><span class="line">    第一行文字内容<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    第二行文字内容<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    第三行文字内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（8）strong、em标签 ：需要强调时使用。strong标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，em标签强调效果仅次于strong标签；<br>b、i标签：只是用于显示效果时使用，在SEO中不会起任何效果。</p><p>（9）文本缩进不要使用特殊符号 &nbsp; 应当使用CSS进行设置。版权符号不要使用特殊符号 &copy; 可以直接使用输入法打出版权符号©。</p><p>（10）重要内容不要用JS输出，因为“蜘蛛”不会读取JS里的内容，所以重要内容必须放在HTML里。</p><p>（11）尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容。</p><p>（12）谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或缩进设置成足够大的负数偏离出浏览器之外。因为搜索引擎会过滤掉display:none其中的内容。</p><p>3、前端网站性能优化</p><p>（1）减少http请求数量</p><p>在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。</p><p><strong>CSS Sprites</strong></p><p>国内俗称CSS精灵，这是将多张图片合并成一张图片达到减少HTTP请求的一种解决方案，可以通过CSS的background属性来访问图片内容。这种方案同时还可以减少图片总字节数。</p><p><strong>合并CSS和JS文件</strong></p><p>现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个CSS或者多个JS合并成一个文件。</p><p><strong>采用lazyload</strong></p><p>俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。</p><p>（2）控制资源文件加载优先级</p><p>浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。</p><p>一般情况下都是CSS在头部，JS在底部。</p><p>（3）尽量外链CSS和JS（结构、表现和行为的分离），保证网页代码的整洁，也有利于日后维护</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"asstes/css/style.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"assets/js/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）利用浏览器缓存</p><p>浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。</p><p>（5）减少重排（Reflow）</p><p>基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。</p><p>减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。</p><p>（6）减少 DOM 操作</p><p>（7）图标使用IconFont替换</p><p>（8）不使用CSS表达式，会影响效率</p><p>（9）使用CDN网络缓存，加快用户访问速度，减轻服务器压力</p><p>（10）启用GZIP压缩，浏览速度变快，搜索引擎的蜘蛛抓取信息量也会增大</p><p>（11）伪静态设置</p><p>如果是动态网页，可以开启伪静态功能，让蜘蛛“误以为”这是静态网页，因为静态网页比较合蜘蛛的胃口，如果url中带有关键词效果更好。</p><p><strong>结束语：</strong>正确认识SEO，不过分SEO，网站还是以内容为主。</p><p>如果是动态网页，可以开启伪静态功能，让蜘蛛“误以为”这是静态网页，因为静态网页比较合蜘蛛的胃口，如果url中带有关键词效果更好。</p><p>动态地址：<a href="http://www.360.cn/index.php" target="_blank" rel="noopener">http://www.360.cn/index.php</a></p><p>伪静态地址：<a href="http://www.360.cn/index.html" target="_blank" rel="noopener">http://www.360.cn/index.html</a></p><p><a href="https://juejin.im/post/5cb5427ff265da03b4460751" target="_blank" rel="noopener">转载</a>：<a href="https://juejin.im/post/5cb5427ff265da03b4460751" target="_blank" rel="noopener">https://juejin.im/post/5cb5427ff265da03b4460751</a></p>]]></content>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web标准和浏览器内核(理解)</title>
      <link href="/2019/03/15/Web%E6%A0%87%E5%87%86%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8-%E7%90%86%E8%A7%A3/"/>
      <content type="html"><![CDATA[<p>Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。<br>主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结构标准：结构用于对网页元素进行整理和分类，咱们主要学的是HTML。</span><br><span class="line">表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。</span><br><span class="line">行为标准：行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript。</span><br></pre></td></tr></table></figure><h3 id="Web标准的好处"><a href="#Web标准的好处" class="headerlink" title="Web标准的好处"></a>Web标准的好处</h3><ol><li>让Web的发展前景更广阔</li><li>内容能被更广泛的设备访问</li><li>更容易被搜寻引擎搜索</li><li>降低网站流量费用</li><li>使网站更易于维护</li><li>提高页面浏览速度</li></ol><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering Engine)和<span class="keyword">JS</span>引擎。</span><br><span class="line"></span><br><span class="line">渲染引擎：它负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入CSS等),以及计算网页的显示方式,然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同,所以渲染的效果也不相同。</span><br><span class="line"></span><br><span class="line"><span class="keyword">JS</span>引擎：则是解析Javascript语言，执行 javascript语言来实现网页的动态效果。</span><br><span class="line"></span><br><span class="line">  最开始渲染引擎和<span class="keyword">JS</span>引擎并没有区分的很明确,后来<span class="keyword">JS</span>引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个ACID来测试引擎的兼容性和性能。内核的种类很多,如加上没什么人使用的非商业的免费内核,可能会有<span class="number">10</span>多种,但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。</span><br></pre></td></tr></table></figure><p>（1） Trident(IE内核)<br>国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。<br>代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。<br>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。</p><p>（2）Gecko(firefox)<br>Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</p><p>（3） webkit(Safari)<br>Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。<br>现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。<br>代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器。</p><p>（4） Chromium/Blink(chrome)<br>在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。<br>大部分国产浏览器最新版都采用Blink内核。二次开发</p><p>（5） Presto(Opera)<br>Presto（已经废弃） 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。</p><p><strong>了解一点：</strong></p><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。<br>Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。<br>iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的</p>]]></content>
      
      
        <tags>
            
            <tag> Web标准 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
