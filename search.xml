<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Less</title>
      <link href="/2019/07/08/Less/"/>
      <content type="html"><![CDATA[<p>Less 是一门 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。</p><a id="more"></a><h3 id="CSS预编译less"><a href="#CSS预编译less" class="headerlink" title="CSS预编译less"></a>CSS预编译less</h3><p>less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展LESS 既可以在 客户端 上运行，也可以借助Node.js在服务端运行。</p><pre><code>less的中文官网：http://lesscss.cn/bootstrap中less教程：http://www.bootcss.com/p/lesscss/</code></pre><h4 id="Less编译工具"><a href="#Less编译工具" class="headerlink" title="Less编译工具"></a>Less编译工具</h4><p><a href="www.koala-app.com">koala官网</a></p><h4 id="less中的注释"><a href="#less中的注释" class="headerlink" title="less中的注释"></a>less中的注释</h4><ul><li>以//开头的注释，不会被编译到css文件中</li></ul><ul><li>以/**/包裹的注释会被编译到css文件中 </li></ul><p>   ​    </p><h4 id="less中的变量"><a href="#less中的变量" class="headerlink" title="less中的变量"></a>less中的变量</h4><p>使用@来申明一个变量：@pink：pink;</p><ol><li><p>作为普通属性值只来使用：直接使用@pink</p></li><li><p>作为选择器和属性名：#@{selector的值}的形式</p></li><li><p>作为URL：@{url}</p></li><li><p>变量的延迟加载</p></li></ol><h4 id="less中的嵌套规则"><a href="#less中的嵌套规则" class="headerlink" title="less中的嵌套规则"></a>less中的嵌套规则</h4><ol><li><p>基本嵌套规则</p></li><li><p>&amp;的使用</p></li></ol><h4 id="less中的混合"><a href="#less中的混合" class="headerlink" title="less中的混合"></a>less中的混合</h4><p>混合就是将一系列属性从一个规则集引入到另一个规则集的方式</p><ol><li><p>普通混合（编译到原生CSS中的）  </p></li><li><p>不带输出的混合</p></li><li><p>带参数的混合</p></li><li><p>带参数并且有默认值的混合</p></li><li><p>带多个参数的混合</p></li><li><p>命名参数</p></li><li><p>匹配模式</p></li><li><p>arguments变量</p></li></ol><h4 id="less运算"><a href="#less运算" class="headerlink" title="less运算"></a>less运算</h4><ol><li><p>在less中可以进行加减乘除的运算</p></li><li><p>计算的一方带单位</p></li></ol><h4 id="less继承"><a href="#less继承" class="headerlink" title="less继承"></a>less继承</h4><ol><li><p>性能比混合高</p></li><li><p>灵活度比混合低</p></li></ol><h4 id="less避免编译"><a href="#less避免编译" class="headerlink" title="less避免编译"></a>less避免编译</h4>]]></content>
      
      
        <tags>
            
            <tag> less </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS模块化规范</title>
      <link href="/2019/06/28/JS%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83/"/>
      <content type="html"><![CDATA[<p>当项目功能越来越多，代码量便也会越来越多，后期的维护难度会增大，此时在JS方面就会考虑使用模块化规范去管理。</p><a id="more"></a><h3 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h3><ol><li><p>什么是模块?</p><ul><li><p>将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起</p></li><li><p>块的内部数据/实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信</p></li></ul></li></ol><ol start="2"><li><p>一个模块的组成</p><ul><li><p>数据—&gt;内部的属性</p></li><li><p>操作数据的行为—&gt;内部的函数</p></li></ul></li></ol><ol start="3"><li><p>模块化</p><ul><li>编码时是按照模块一个一个编码的, 整个项目就是一个模块化的项目</li></ul></li></ol><ol start="4"><li>模块化的进化过程<ul><li>全局function模式 : <ul><li>编码: 全局变量/函数</li><li>问题: 污染全局命名空间, 容易引起命名冲突/数据不安全</li></ul></li><li>namespace模式 : <ul><li>编码: 将数据/行为封装到对象中</li><li>解决: 命名冲突(减少了全局变量)</li><li>问题: 数据不安全(外部可以直接修改模块内部的数据)</li></ul></li><li>IIFE模式/增强<ul><li>IIFE : 立即调用函数表达式—&gt;匿名函数自调用</li><li>编码: 将数据和行为封装到一个函数内部, 通过给window添加属性来向外暴露接口</li><li>引入依赖: 通过函数形参来引入依赖模块<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line">(<span class="name">function</span>(<span class="name">window</span>, module2)&#123;</span><br><span class="line">  var data = 'atguigu.com'</span><br><span class="line">  function foo() &#123;</span><br><span class="line">     module2.xxx()</span><br><span class="line">     console.log(<span class="name">'foo</span>()'+data)</span><br><span class="line">  &#125;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">     console.log(<span class="name">'bar</span>()'+data)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  window.module = &#123;foo&#125;</span><br><span class="line">&#125;)(<span class="name">window</span>, module2)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h3><ol><li><p><strong>CommonJS</strong></p><ul><li><p>Node.js : 服务器端</p></li><li><p>Browserify : 浏览器端    也称为js的打包工具</p></li><li><p>基本语法:</p><ul><li>定义暴露模块 : exports<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">exports.xxx</span> = value</span><br><span class="line"><span class="attr">module.exports</span> = value</span><br></pre></td></tr></table></figure></li></ul><p>引入模块 : require</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'模块名/模块相对路径'</span>)</span><br></pre></td></tr></table></figure></li><li><p>引入模块发生在什么时候?</p><ul><li><p>Node : 运行时, 动态同步引入</p></li><li><p>Browserify : 在运行前对模块进行编译/转译/打包的处理(已经将依赖的模块包含进来了), </p><pre><code>运行的是打包生成的js, 运行时不存在需要再从远程引入依赖模块</code></pre></li></ul></li></ul></li></ol><p>​           </p><ol start="2"><li><p><strong>AMD : 浏览器端</strong></p><ul><li>require.js</li><li>基本语法<ul><li>定义暴露模块: define([依赖模块名], function(){return 模块对象})</li><li>引入模块: require([‘模块1’, ‘模块2’, ‘模块3’], function(m1, m2){//使用模块对象})</li><li>配置: <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">require.config(&#123;</span><br><span class="line">  <span class="comment">//基本路径</span></span><br><span class="line">  <span class="string">baseUrl :</span> <span class="string">'js/'</span>,</span><br><span class="line">  <span class="comment">//标识名称与路径的映射</span></span><br><span class="line">  <span class="string">paths :</span> &#123;</span><br><span class="line">    <span class="string">'模块1'</span> : <span class="string">'modules/模块1'</span>,</span><br><span class="line">    <span class="string">'模块2'</span> : <span class="string">'modules/模块2'</span>,</span><br><span class="line">    <span class="string">'angular'</span> : <span class="string">'libs/angular'</span>,</span><br><span class="line">    <span class="string">'angular-messages'</span> : <span class="string">'libs/angular-messages'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//非AMD的模块</span></span><br><span class="line">  <span class="string">shim :</span> &#123;</span><br><span class="line">    <span class="string">'angular'</span> : &#123;</span><br><span class="line">        <span class="string">exports :</span> <span class="string">'angular'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'angular-messages'</span> : &#123;</span><br><span class="line">        <span class="string">exports :</span> <span class="string">'angular-messages'</span>,</span><br><span class="line">        <span class="string">deps :</span> [<span class="string">'angular'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><p>​    </p><ol start="3"><li><p><strong>CMD : 浏览器端</strong></p><ul><li>sea.js</li><li>基本语法<ul><li>定义暴露模块: <figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">define(function(<span class="keyword">require</span>, <span class="class"><span class="keyword">module</span>, <span class="title">exports</span>)&#123;</span></span><br><span class="line">  通过<span class="keyword">require</span>引入依赖模块</span><br><span class="line">  通过<span class="class"><span class="keyword">module</span>/<span class="title">exports</span>来暴露模块</span></span><br><span class="line">  exports.xxx = value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><pre><code>* 使用模块seajs.use([&apos;模块1&apos;, &apos;模块2&apos;])</code></pre><p>​        </p><ol start="4"><li><p><strong>ES6</strong></p><ul><li><p>ES6内置了模块化的实现</p></li><li><p>基本语法</p></li><li><p>定义暴露模块 : export</p><ul><li><p>暴露一个对象: </p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span><span class="built_in"> default </span>对象</span><br></pre></td></tr></table></figure></li><li><p>暴露多个: </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> xxx = value1</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> yyy = value2</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xxx = value1</span><br><span class="line"><span class="keyword">let</span> yyy = value2</span><br><span class="line"><span class="keyword">export</span> &#123;xxx, yyy&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><pre><code>  * 引入使用模块 : import    * default模块:      <figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xxx  <span class="keyword">from</span> <span class="string">'模块路径/模块名'</span></span><br></pre></td></tr></table></figure>    * 其它模块      <figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;xxx, yyy&#125; <span class="keyword">from</span> <span class="string">'模块路径/模块名'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> module1 <span class="keyword">from</span> <span class="string">'模块路径/模块名'</span></span><br></pre></td></tr></table></figure>* 问题: 所有浏览器还不能直接识别ES6模块化的语法  * 解决:    * 使用Babel将ES6---&gt;ES5(使用了CommonJS) ----浏览器还不能直接支行    * 使用Browserify---&gt;打包处理----浏览器可以运行</code></pre>]]></content>
      
      
        <tags>
            
            <tag> JS模块化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ECMAScript</title>
      <link href="/2019/06/10/ECMAScript/"/>
      <content type="html"><![CDATA[<p><a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript</a>(俗称: ES5, ES6)规范、尤其ES6是JavaScript 语言的下一代标准，它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p><a id="more"></a><h3 id="理解ES"><a href="#理解ES" class="headerlink" title="理解ES"></a><strong>理解ES</strong></h3><ol><li>全称: ECMAScript</li><li>js语言的规范</li><li>我们用的js是它的实现</li><li>js的组成<ul><li>ECMAScript(js基础)</li><li>扩展–&gt;浏览器端<ul><li>BOM</li><li>DOM</li></ul></li><li>扩展–&gt;服务器端<ul><li>Node.js</li></ul></li></ul></li></ol><p>​      </p><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><ol><li><p><strong>严格模式</strong></p><ul><li><p>运行模式: 正常(混杂)模式与严格模式</p></li><li><p>应用上严格式: ‘strict mode’;</p></li><li><p>作用: </p><ul><li><p>使得Javascript在更严格的条件下运行</p></li><li><p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</p></li><li><p>消除代码运行的一些不安全之处，保证代码运行的安全</p></li><li><p>需要记住的几个变化</p><ul><li><p>声明定义变量必须用var</p></li><li><p>禁止自定义的函数中的this关键字指向全局对象</p></li><li><p>创建eval作用域, 更安全</p></li></ul></li></ul></li></ul></li></ol><ol start="2"><li><p><strong>JSON对象</strong></p><ul><li><p>作用: 用于在json对象/数组与js对象/数组相互转换</p></li><li><p>JSON.stringify(obj/arr)<br> js对象(数组)转换为json对象(数组)</p></li><li><p>JSON.parse(json)<br> json对象(数组)转换为js对象(数组)</p></li></ul></li></ol><ol start="3"><li><p><strong>Object扩展</strong></p><ul><li><p>Object.create(prototype[, descriptors]) : 创建一个新的对象</p><ul><li>以指定对象为原型创建新的对象</li><li>指定新的属性, 并对属性进行描述<ul><li>value : 指定值</li><li>writable : 标识当前属性值是否是可修改的, 默认为true</li><li><strong>get方法</strong> : 用来得到当前属性值的回调函数</li><li><strong>set方法</strong> : 用来监视当前属性值变化的回调函数</li></ul></li></ul></li><li><p>Object.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性</p></li></ul></li></ol><ol start="4"><li><p><strong>Array扩展</strong></p><ul><li><p>Array.prototype.indexOf(value) : 得到值在数组中的第一个下标</p></li><li><p>Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标</p></li><li><p><strong>Array.prototype.forEach(function(item, index){}) : 遍历数组</strong></p></li><li><p><strong>Array.prototype.map(function(item, index){}) : 遍历数组返回一个新的数组</strong></p></li><li><p><strong>Array.prototype.filter(function(item, index){}) : 遍历过滤出一个子数组</strong></p></li></ul></li></ol><ol start="5"><li><p><strong>Function扩展</strong></p><ul><li><p>Function.prototype.bind(obj)</p><ul><li>将函数内的this绑定为obj, 并将函数返回</li></ul></li><li><p>面试题: 区别bind()与call()和apply()?</p><ul><li><p>fn.bind(obj) : 指定函数中的this, 并返回函数</p></li><li><p>fn.call(obj) : 指定函数中的this,并调用函数</p></li></ul></li></ul></li></ol><ol start="6"><li><strong>Date扩展</strong><ul><li>Date.now() : 得到当前时间值</li></ul></li></ol><h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3><ol><li><p><strong>2个新的关键字</strong></p><ul><li><p>let/const</p></li><li><p>块作用域</p></li><li><p>没有变量提升</p></li><li><p>不能重复定义</p></li><li><p>值不可变</p></li></ul></li></ol><ol start="2"><li><p><strong>变量的解构赋值</strong></p><ul><li><p>将包含多个数据的对象(数组)一次赋值给多个变量</p></li><li><p>数据源: 对象/数组</p></li><li><p>目标: {a, b}/[a, b]</p></li></ul></li></ol><ol start="3"><li><p><strong>各种数据类型的扩展</strong></p><ul><li><p>字符串</p><ul><li><strong>模板字符串</strong> <ul><li>作用: 简化字符串的拼接</li><li>模板字符串必须用``</li><li>变化的部分使用${xxx}定义</li></ul></li><li>contains(str) : 判断是否包含指定的字符串</li><li>startsWith(str) : 判断是否以指定字符串开头</li><li>endsWith(str) : 判断是否以指定字符串结尾</li><li>repeat(count) : 重复指定次数</li></ul></li><li><p>对象</p><ul><li><p><strong>简化的对象写法</strong></p><figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span><span class="built_in"> name</span> = <span class="string">'Tom'</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">   <span class="built_in"> name</span>,</span><br><span class="line">    age,</span><br><span class="line">    setName <span class="built_in">(name</span>) &#123;</span><br><span class="line">        this<span class="built_in">.name</span> =<span class="built_in"> name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>Object.assign(target, source1, source2..) : 将源对象的属性复制到目标对象上</p></li><li><p>Object.is(v1, v2) : 判断2个数据是否完全相等</p></li><li><p><strong>proto</strong>属性 : 隐式原型属性</p></li></ul></li><li><p>数组</p><ul><li>Array.from(v) : 将伪数组对象或可遍历对象转换为真数组</li><li>Array.of(v1, v2, v3) : 将一系列值转换成数组</li><li>find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素</li><li>findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标</li></ul></li><li><p>函数</p><ul><li><p><strong>箭头函数</strong></p><ul><li>用来定义匿名函数</li><li>基本语法:<ul><li>没有参数: () =&gt; console.log(‘xxxx’)</li><li>一个参数: i =&gt; i+2</li><li>大于一个参数: (i,j) =&gt; i+j</li><li>函数体不用大括号: 默认返回结果</li><li>函数体如果有多个语句, 需要用{}包围</li></ul></li><li>使用场景: 多用来定义回调函数</li></ul></li><li><p><strong>形参的默认值</strong></p><ul><li>定义形参时指定其默认的值</li></ul></li><li><p><strong>rest(可变)参数</strong></p><ul><li>通过形参左侧的…来表达, 取代arguments的使用</li></ul></li><li><p><strong>扩展运算符(…)</strong></p><ul><li>可以分解出数组或对象中的数据</li></ul></li></ul></li></ul></li></ol><ol start="4"><li><p><strong>set/Map容器结构</strong></p><ul><li><p>容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法</p></li><li><p>任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数)</p></li><li><p><strong>Set的特点</strong>: 保存多个value, value是不重复 ====&gt;数组元素去重</p></li><li><p><strong>Map的特点</strong>: 保存多个key–value, key是不重复, value是可以重复的</p></li><li><p>API</p><ul><li><p>Set()/Set(arr)  //arr是一维数组</p></li><li><p>add(value)</p></li><li><p>delete(value)</p></li><li><p>clear();</p></li><li><p>has(value)</p></li><li><p>size</p></li><li></li><li><p>Map()/Map(arr)  //arr是二维数组</p></li><li><p>set(key, value)</p></li><li><p>delete(key)</p></li><li><p>clear()</p></li><li><p>has(key)</p></li><li><p>size</p></li></ul></li></ul></li></ol><ol start="5"><li><p><strong>for–of循环</strong></p><ul><li><p>可以遍历任何容器</p></li><li><p>数组</p></li><li><p>对象</p></li><li><p>伪/类对象</p></li><li><p>字符串</p></li><li><p>可迭代的对象</p></li></ul></li></ol><ol start="6"><li><p><strong>Promise</strong></p><ul><li><p>解决<code>回调地狱</code>(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差)</p></li><li><p>能以同步编码的方式实现异步调用</p></li><li><p>在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise</p></li><li><p>ES6中定义实现API: </p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 创建promise对象</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123; </span><br><span class="line">  <span class="comment">// 做异步的操作 </span></span><br><span class="line">  <span class="keyword">if</span>(成功) &#123; <span class="comment">// 调用成功的回调</span></span><br><span class="line">    resolve(result); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 调用失败的回调</span></span><br><span class="line">    reject(errorMsg); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// 2. 调用promise对象的then()</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  result =&gt; <span class="built_in">console</span>.log(result), </span></span></span><br><span class="line"><span class="function"><span class="params">  errorMsg =&gt; alert(errorMsg)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>))</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>class类</strong></p><ul><li>用 class 定义一类</li><li>用 constructor() 定义构造方法(相当于构造函数)</li><li>一般方法: xxx () {}</li><li>用extends来定义子类</li><li>用super()来父类的构造方法</li><li>子类方法自定义: 将从父类中继承来的方法重新实现一遍</li><li>js中没有方法重载(方法名相同, 但参数不同)的语法</li></ul></li></ol><h3 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h3><ul><li><p>指数运算符: **</p></li><li><p>Array.prototype.includes(value) : 判断数组中是否包含指定value</p></li><li><p><strong>区别方法的2种称谓</strong></p><ul><li>静态(工具)方法<ul><li>Fun.xxx = function(){}</li></ul></li><li>实例方法<ul><li>所有实例对象 : Fun.prototype.xxx = function(){} //xxx针对Fun的所有实例对象</li><li>某个实例对象 : fun.xxx = function(){} //xxx只是针对fun对象</li></ul></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> ES5_6_7 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ajax初识</title>
      <link href="/2019/05/25/ajax%E5%88%9D%E8%AF%86/"/>
      <content type="html"><![CDATA[<p>AJAX就是浏览器提供的一套API，可以通过代码控制请求与响应，实现网络编程。</p><a id="more"></a><h3 id="发送Ajax请求步骤"><a href="#发送Ajax请求步骤" class="headerlink" title="发送Ajax请求步骤"></a>发送Ajax请求步骤</h3><ol><li>创建XMLHttpRequest对象</li><li>准备发送</li><li>执行发送动作</li><li>指定回调函数</li></ol><p><img src="/resource/ajax.png" alt="ajax—回调函数"></p><p><strong>get：</strong></p><ul><li>get请求参数在url中传递</li><li>需要注意编码问题</li></ul><p><strong>post：</strong></p><ul><li>post请求参数在请求体中传递</li><li>需要设置请求头信息</li></ul><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>页面加载的同步与异步（白屏与不刷新）</p><ol><li>普通的页面效果：w3school.org</li><li>页面不刷新效果：评论加载</li></ol><p>描述两者之间的行为方式</p><ol><li><strong>同步</strong> 彼此等待 — 阻塞</li><li><strong>异步</strong>  各做各的 —  非阻塞</li></ol><h3 id="ajax的封装"><a href="#ajax的封装" class="headerlink" title="ajax的封装"></a>ajax的封装</h3><p>默认参数</p><p>出来形参，传递参数的时候覆盖默认参数，不传递就使用默认参数</p><ol><li><p>创建XMLHttpRequest对象</p><p>把对象形式的参数转化为字符串形式的参数</p><p>处理get请求参数并且处理中文乱码问题</p></li></ol><ol start="2"><li><p>准备发送（设置发送的参数）</p><p>处理post请求参数并且设置请求头信息（必须设置）</p></li></ol><ol start="3"><li><p>执行发送动作</p><p>处理同步请求，不会调用回调函数  </p></li></ol><ol start="4"><li>指定回调函数（处理服务器响应数据）</li></ol><h3 id="Ajax跨域"><a href="#Ajax跨域" class="headerlink" title="Ajax跨域"></a>Ajax跨域</h3><p><strong>同源策略</strong></p><ol><li><p>同源策略是浏览器的一种安全策略，所谓同源指的是请求URL地址中的协议、域名和端口都相同，只要其中之一不相同就是跨域</p></li><li><p>同源策略主要为了保证浏览器的安全性</p></li><li><p>在同源策略下，浏览器不允许Ajax跨域获取服务器数据</p></li></ol><h3 id="JSONP原理"><a href="#JSONP原理" class="headerlink" title="JSONP原理"></a>JSONP原理</h3><ol><li>静态script标签的src属性进行跨域请求</li><li>动态创建script标签，通过标签的src属性发送请求</li></ol>]]></content>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络概念</title>
      <link href="/2019/05/03/%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/"/>
      <content type="html"><![CDATA[<p><img src="/resource/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5.png" alt="网络相关概念"></p><a id="more"></a><h3 id="客户端与服务器"><a href="#客户端与服务器" class="headerlink" title="客户端与服务器"></a>客户端与服务器</h3><p>本质上都是计算机，只不过样子不同，配置不同，应用场景不同（安装的应用软件不同）</p><ol><li>客户端主要用于普通上网用户</li><li>服务器主要给上网用户提供后台服务</li></ol><h3 id="网络相关概念"><a href="#网络相关概念" class="headerlink" title="网络相关概念"></a>网络相关概念</h3><ol><li>IP地址（唯一的确定互联网上的一台计算机）</li><li>域名 IP地址的别名，方便记忆</li><li>DNS 用于维护IP地址与域名的关系</li><li>端口 用来确定计算机上的网络应用程序</li></ol><h3 id="通信协议理解"><a href="#通信协议理解" class="headerlink" title="通信协议理解"></a>通信协议理解</h3><p><img src="/resource/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE.png" alt="通信协议"></p><p><strong>通信双方约定的规则</strong></p><ol><li>http/https 超为本传输协议</li><li>ftp 文件传输协议</li><li>smpt/pop3 邮件收发协议</li><li>……</li></ol>]]></content>
      
      
        <tags>
            
            <tag> 网络概念 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端SEO优化</title>
      <link href="/2019/04/28/%E5%89%8D%E7%AB%AFSEO%E4%BC%98%E5%8C%96/"/>
      <content type="html"><![CDATA[<p>SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。</p><a id="more"></a><h4 id="一、-搜索引擎工作原理"><a href="#一、-搜索引擎工作原理" class="headerlink" title="一、 搜索引擎工作原理"></a>一、 搜索引擎工作原理</h4><p>在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从茫茫的互联网上一点一点下载收集而来的。随着各种各样网站的出现，这些勤劳的“蜘蛛”每天在互联网上爬行，从一个链接到另一个链接，下载其中的内容，进行分析提炼，找到其中的关键词，如果“蜘蛛”认为关键词在数据库中没有而对用户是有用的便存入后台的数据库中。反之，如果“蜘蛛”认为是垃圾信息或重复信息，就舍弃不要，继续爬行，寻找最新的、有用的信息保存起来提供用户搜索。当用户搜索时，就能检索出与关键字相关的网址显示给访客。</p><p>一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是flash和js等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。这样一个过程我们称之为SEO。</p><h4 id="二、-SEO简介"><a href="#二、-SEO简介" class="headerlink" title="二、 SEO简介"></a>二、 SEO简介</h4><p>SEO(Search Engine Optimization)，即搜索引擎优化。SEO是随着搜索引擎的出现而来的，两者是相互促进，互利共生的关系。SEO的存在就是为了提升网页在搜索引擎自然搜索结果中的收录数量以及排序位置而做的优化行为。而优化的目的就是为了提升网站在搜索引擎中的权重，增加对搜索引擎的友好度，使得用户在访问网站时能排在前面。</p><p>分类：白帽SEO和黑帽SEO。白帽SEO，起到了改良和规范网站设计的作用，使网站对搜索引擎和用户更加友好，并且网站也能从搜索引擎中获取合理的流量，这是搜索引擎鼓励和支持的。黑帽SEO，利用和放大搜索引擎政策缺陷来获取更多用户的访问量，这类行为大多是欺骗搜索引擎，一般搜索引擎公司是不支持与鼓励的。本文针对白帽SEO，那么白帽SEO能做什么呢？</p><ol><li>对网站的标题、关键字、描述精心设置，反映网站的定位，让搜索引擎明白网站是做什么的；</li><li>网站内容优化：内容与关键字的对应，增加关键字的密度；</li><li>在网站上合理设置Robot.txt文件；</li><li>生成针对搜索引擎友好的网站地图；</li><li>增加外部链接，到各个网站上宣传。</li></ol><h4 id="三、-为什么要做SEO"><a href="#三、-为什么要做SEO" class="headerlink" title="三、 为什么要做SEO"></a>三、 为什么要做SEO</h4><p>提高网站的权重，增强搜索引擎友好度，以达到提高排名，增加流量，改善（潜在）用户体验，促进销售的作用。</p><h4 id="四、-前端SEO规范"><a href="#四、-前端SEO规范" class="headerlink" title="四、 前端SEO规范"></a>四、 前端SEO规范</h4><p>前端是构建网站中很重要的一个环节，前端的工作主要是负责页面的HTML+CSS+JS，优化好这几个方面会为SEO工作打好一个坚实的基础。通过网站的结构布局设计和网页代码优化，使前端页面既能让浏览器用户能够看懂（提升用户体验），也能让“蜘蛛”看懂（提高搜索引擎友好度）。</p><p><strong>前端SEO注意事项：</strong></p><p>1、 网站结构布局优化：尽量简单、开门见山，提倡扁平化结构</p><p>一般而言，建立的网站结构层次越少，越容易被“蜘蛛”抓取，也就容易被收录。一般中小型网站目录结构超过三级，“蜘蛛”便不愿意往下爬了。并且根据相关数据调查：如果访客经过跳转3次还没找到需要的信息，很可能离开。因此，三层目录结构也是体验的需要。为此我们需要做到：</p><p>（1）控制首页链接数量</p><p>网站首页是权重最高的地方，如果首页链接太少，没有“桥”，“蜘蛛”不能继续往下爬到内页，直接影响网站收录数量。但是首页链接也不能太多，一旦太多，没有实质性的链接，很容易影响用户体验，也会降低网站首页的权重，收录效果也不好。</p><p>（2）扁平化的目录层次</p><p>尽量让“蜘蛛”只要跳转3次，就能到达网站内的任何一个内页。</p><p>（3）导航优化</p><p>导航应该尽量采用文字方式，也可以搭配图片导航，但是图片代码一定要进行优化，<img>标签必须添加“alt”和“title”属性，告诉搜索引擎导航的定位，做到即使图片未能正常显示时，用户也能看到提示文字。</p><p>其次，在每一个网页上应该加上面包屑导航，好处：从用户体验方面来说，可以让用户了解当前所处的位置以及当前页面在整个网站中的位置，帮助用户很快了解网站组织形式，从而形成更好的位置感，同时提供了返回各个页面的接口，方便用户操作；对“蜘蛛”而言，能够清楚的了解网站结构，同时还增加了大量的内部链接，方便抓取，降低跳出率。</p><p>（4）网站的结构布局—不可忽略的细节</p><p>页面头部：logo及主导航，以及用户的信息。</p><p>页面主体：左边正文，包括面包屑导航及正文；右边放热门文章及相关文章，好处：留住访客，让访客多停留，对“蜘蛛”而言，这些文章属于相关链接，增强了页面相关性，也能增强页面的权重</p><p>页面底部：版权信息和友情链接。</p><p><strong>特别注意：</strong>分页导航写法，推荐写法：“首页 1 2 3 4 5 6 7 8 9 下拉框”，这样“蜘蛛”能够根据相应页码直接跳转，下拉框直接选择页面跳转。而下面的写法是不推荐的，“首页 下一页 尾页”，特别是当分页数量特别多时，“蜘蛛”需要经过很多次往下爬，才能抓取，会很累、会容易放弃。</p><p>（5）利用布局，把重要内容HTML代码放在最前</p><p>搜索引擎抓取HTML内容是从上到下，利用这一特点，可以让主要代码优先读取，广告等不重要代码放在下边。例如，在左栏和右栏的代码不变的情况下，只需改一下样式，利用float:left;和float:right;就可以随意让两栏在展现上位置互换，这样就可以保证重要代码在最前，让爬虫最先抓取。同样也适用于多栏的情况。</p><p>（6）控制页面的大小，减少http请求，提高网站的加载速度。</p><p>一个页面最好不要超过100k，太大，页面加载速度慢。当速度很慢时，用户体验不好，留不住访客，并且一旦超时，“蜘蛛”也会离开。</p><p>2、网页代码优化</p><p>（1）突出重要内容—合理的设计title、description和keywords</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的<span class="tag">&lt;<span class="name">title</span>&gt;</span>标题中不要设置相同的内容。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">keywords</span>&gt;</span>标签：关键词，列举出几个页面的重要关键字即可，切记过分堆砌。</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">description</span>&gt;</span>标签：网页描述，需要高度概括网页内容，切记不能太长，过分堆砌关键词，每个页面也要有所不同。</span><br></pre></td></tr></table></figure><p>（2）语义化书写HTML代码，符合W3C标准</p><p>尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事。让阅读源码者和“蜘蛛”都一目了然。比如：h1-h6 是用于标题类的，nav标签是用来设置页面主导航，列表形式的代码使用ul或ol，重要的文字使用strong等。</p><p>（3）a标签：页内链接，要加 “title” 属性加以说明，让访客和 “蜘蛛” 知道。而外部链接，链接到其他网站的，则需要加上 el=”nofollow” 属性, 告诉 “蜘蛛” 不要爬，因为一旦“蜘蛛”爬了外部链接之后，就不会再回来了。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.360.cn"</span> <span class="attr">title</span>=<span class="string">"360安全中心"</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）正文标题要用h1标签：h1标签自带权重“蜘蛛” 认为它最重要，一个页面有且最多只能有一个H1标签，放在该页面最重要的标题上面，如首页的logo上可以加H1标签。副标题用h2标签, 而其它地方不应该随便乱用 h 标题标签。</p><p>（5）img应使用 “alt” 属性加以说明</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"cat.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"猫"</span>  /&gt;</span></span><br></pre></td></tr></table></figure><p>当网络速度很慢，或者图片地址失效的时候，就可以体现出alt属性的作用，他可以让用户在图片没有显示的时候知道这个图片的作用。同时为图片设置高度和宽度，可提高页面的加载速度。</p><p>（6）表格应该使用caption表格标题标签</p><p>caption 元素定义表格标题。caption 标签必须紧随 table 标签之后，您只能对每个表格定义</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">'1'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>100<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>banana<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>200<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（7）br标签：只用于文本内容的换行，比如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> </span><br><span class="line">    第一行文字内容<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    第二行文字内容<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    第三行文字内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（8）strong、em标签 ：需要强调时使用。strong标签在搜索引擎中能够得到高度的重视，它能突出关键词，表现重要的内容，em标签强调效果仅次于strong标签；<br>b、i标签：只是用于显示效果时使用，在SEO中不会起任何效果。</p><p>（9）文本缩进不要使用特殊符号 &nbsp; 应当使用CSS进行设置。版权符号不要使用特殊符号 &copy; 可以直接使用输入法打出版权符号©。</p><p>（10）重要内容不要用JS输出，因为“蜘蛛”不会读取JS里的内容，所以重要内容必须放在HTML里。</p><p>（11）尽量少使用iframe框架,因为“蜘蛛”一般不会读取其中的内容。</p><p>（12）谨慎使用 display：none ：对于不想显示的文字内容，应当设置z-index或缩进设置成足够大的负数偏离出浏览器之外。因为搜索引擎会过滤掉display:none其中的内容。</p><p>3、前端网站性能优化</p><p>（1）减少http请求数量</p><p>在浏览器与服务器进行通信时，主要是通过 HTTP 进行通信。浏览器与服务器需要经过三次握手，每次握手需要花费大量时间。而且不同浏览器对资源文件并发请求数量有限（不同浏览器允许并发数），一旦 HTTP 请求数量达到一定数量，资源请求就存在等待状态，这是很致命的，因此减少 HTTP 的请求数量可以很大程度上对网站性能进行优化。</p><p><strong>CSS Sprites</strong></p><p>国内俗称CSS精灵，这是将多张图片合并成一张图片达到减少HTTP请求的一种解决方案，可以通过CSS的background属性来访问图片内容。这种方案同时还可以减少图片总字节数。</p><p><strong>合并CSS和JS文件</strong></p><p>现在前端有很多工程化打包工具，如：grunt、gulp、webpack等。为了减少 HTTP 请求数量，可以通过这些工具再发布前将多个CSS或者多个JS合并成一个文件。</p><p><strong>采用lazyload</strong></p><p>俗称懒加载，可以控制网页上的内容在一开始无需加载，不需要发请求，等到用户操作真正需要的时候立即加载出内容。这样就控制了网页资源一次性请求数量。</p><p>（2）控制资源文件加载优先级</p><p>浏览器在加载HTML内容时，是将HTML内容从上至下依次解析，解析到link或者script标签就会加载href或者src对应链接内容，为了第一时间展示页面给用户，就需要将CSS提前加载，不要受 JS 加载影响。</p><p>一般情况下都是CSS在头部，JS在底部。</p><p>（3）尽量外链CSS和JS（结构、表现和行为的分离），保证网页代码的整洁，也有利于日后维护</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"asstes/css/style.css"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"assets/js/main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）利用浏览器缓存</p><p>浏览器缓存是将网络资源存储在本地，等待下次请求该资源时，如果资源已经存在就不需要到服务器重新请求该资源，直接在本地读取该资源。</p><p>（5）减少重排（Reflow）</p><p>基本原理：重排是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证 DOM 树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如果Reflow的过于频繁，CPU使用率就会急剧上升。</p><p>减少Reflow，如果需要在DOM操作时添加样式，尽量使用 增加class属性，而不是通过style操作样式。</p><p>（6）减少 DOM 操作</p><p>（7）图标使用IconFont替换</p><p>（8）不使用CSS表达式，会影响效率</p><p>（9）使用CDN网络缓存，加快用户访问速度，减轻服务器压力</p><p>（10）启用GZIP压缩，浏览速度变快，搜索引擎的蜘蛛抓取信息量也会增大</p><p>（11）伪静态设置</p><p>如果是动态网页，可以开启伪静态功能，让蜘蛛“误以为”这是静态网页，因为静态网页比较合蜘蛛的胃口，如果url中带有关键词效果更好。</p><p><strong>结束语：</strong>正确认识SEO，不过分SEO，网站还是以内容为主。</p><p>如果是动态网页，可以开启伪静态功能，让蜘蛛“误以为”这是静态网页，因为静态网页比较合蜘蛛的胃口，如果url中带有关键词效果更好。</p><p>动态地址：<a href="http://www.360.cn/index.php" target="_blank" rel="noopener">http://www.360.cn/index.php</a></p><p>伪静态地址：<a href="http://www.360.cn/index.html" target="_blank" rel="noopener">http://www.360.cn/index.html</a></p><p><a href="https://juejin.im/post/5cb5427ff265da03b4460751" target="_blank" rel="noopener">转载</a>：<a href="https://juejin.im/post/5cb5427ff265da03b4460751" target="_blank" rel="noopener">https://juejin.im/post/5cb5427ff265da03b4460751</a></p>]]></content>
      
      
        <tags>
            
            <tag> SEO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web标准和浏览器内核(理解)</title>
      <link href="/2019/03/15/Web%E6%A0%87%E5%87%86%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8-%E7%90%86%E8%A7%A3/"/>
      <content type="html"><![CDATA[<p>Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。<br>主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">结构标准：结构用于对网页元素进行整理和分类，咱们主要学的是HTML。</span><br><span class="line">表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。</span><br><span class="line">行为标准：行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript。</span><br></pre></td></tr></table></figure><h3 id="Web标准的好处"><a href="#Web标准的好处" class="headerlink" title="Web标准的好处"></a>Web标准的好处</h3><ol><li>让Web的发展前景更广阔</li><li>内容能被更广泛的设备访问</li><li>更容易被搜寻引擎搜索</li><li>降低网站流量费用</li><li>使网站更易于维护</li><li>提高页面浏览速度</li></ol><h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">浏览器内核又可以分成两部分：渲染引擎(layout engineer或者Rendering Engine)和<span class="keyword">JS</span>引擎。</span><br><span class="line"></span><br><span class="line">渲染引擎：它负责取得网页的内容(HTML、XML、图像等等)、整理讯息(例如加入CSS等),以及计算网页的显示方式,然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同,所以渲染的效果也不相同。</span><br><span class="line"></span><br><span class="line"><span class="keyword">JS</span>引擎：则是解析Javascript语言，执行 javascript语言来实现网页的动态效果。</span><br><span class="line"></span><br><span class="line">  最开始渲染引擎和<span class="keyword">JS</span>引擎并没有区分的很明确,后来<span class="keyword">JS</span>引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个ACID来测试引擎的兼容性和性能。内核的种类很多,如加上没什么人使用的非商业的免费内核,可能会有<span class="number">10</span>多种,但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。</span><br></pre></td></tr></table></figure><p>（1） Trident(IE内核)<br>国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。<br>代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。<br>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。</p><p>（2）Gecko(firefox)<br>Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</p><p>（3） webkit(Safari)<br>Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。<br>现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。<br>代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器。</p><p>（4） Chromium/Blink(chrome)<br>在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。<br>大部分国产浏览器最新版都采用Blink内核。二次开发</p><p>（5） Presto(Opera)<br>Presto（已经废弃） 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。</p><p><strong>了解一点：</strong></p><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。<br>Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。<br>iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的</p>]]></content>
      
      
        <tags>
            
            <tag> Web标准 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
